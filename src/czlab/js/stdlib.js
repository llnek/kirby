/*Auto generated by Kirby v1.0.0 - Mon Jun 28 2021 01:07:41 GMT-0700 (Pacific Daylight Time)
  czlab.kirby.stdlib
{"author" "Kenneth Leung" "doc" "Standard core library containing built-in functions/vars and macros."}
*/

const core = require("./core");
const __module_namespace__ = "czlab.kirby.stdlib";
const MAX_DASH_INT = Number.MAX_SAFE_INTEGER;
const MIN_DASH_INT = Number.MIN_SAFE_INTEGER;
var DArray = core.DArray;
var SPair = core.SPair;
var Atom = core.Atom;
var Keyword = core.Keyword;
var Symbol = core.Symbol;
////////////////////////////////////////////////////////////////////////////////
//fn: [rtti] in file: stdlib.ky, line: 1271
//Runtime type info of this object.
function rtti(obj) {
  return Object.prototype.toString.call(obj);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [rtti?] in file: stdlib.ky, line: 1279
//Check the runtime type info of this object.
function rtti_QMRK(obj, t) {
  return (Object.prototype.toString.call(obj) == t);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [println] in file: stdlib.ky, line: 1287
//Write msg to console.
function println() {
  let msgs = Array.prototype.slice.call(arguments, 0);
  return (console ?
    console.log(msgs.join("")) :
    null);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [not-empty] in file: stdlib.ky, line: 1295
//Check if coll is empty, returns nil, else coll.
function not_DASH_empty(coll) {
  return ((0 == count(coll)) ?
    null :
    coll);
}
//////////////////////////////////////////////////////////////////////////////;
////////////////////////////////////////////////////////////////////////////////
//fn: [is-simple?] in file: stdlib.ky, line: 1303
//Check if input is a primitive type.
function is_DASH_simple_QMRK(x) {
  return ((typeof (x) == "boolean") || (typeof (x) == "string") || (typeof (x) == "number") || (x === null) || (x === undefined));
}
////////////////////////////////////////////////////////////////////////////////
//fn: [no-cref] in file: stdlib.ky, line: 1315
//Use a cache to store already referenced objects
//  to prevent circular references.
function no_DASH_cref() {
  let cache = vector();
  return function(k, v) {
    if(( (typeof (v) == "function") )) {
      (
      v = (v.name || "native"));
    } else {
      if( (!is_DASH_simple_QMRK(v)) ) {
        if (true) {
          if (contains_QMRK(cache, v)) {
            (
            v = undefined);
          } else {
            conj_BANG(cache, v)
          }
        }
      }
    }
    return v;
  };
}
////////////////////////////////////////////////////////////////////////////////
//fn: [stringify] in file: stdlib.ky, line: 1331
/* {"tag" String} */
//JSON stringify (no cyclical obj-ref)
function stringify(obj) {
  return (obj ?
    JSON.stringify(obj, no_DASH_cref()) :
    null);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [opt??] in file: stdlib.ky, line: 1339
/* {"tag" Any} */
//If cur is not defined, returns other else cur
function opt_QMRK__QMRK(cur, other) {
  return (((typeof (cur) != "undefined")) ?
    cur :
    other);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [cons!] in file: stdlib.ky, line: 1347
//Adds one element to the beginning of a collection.
function cons_BANG(x, coll) {
  if (Array.isArray(coll)) {
    coll.unshift(x);
  }
  return coll;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [conj!] in file: stdlib.ky, line: 1355
/* {"tag" Any} */
//conj[oin]. Returns coll with the xs
//  'added'. (conj! nil item) returns [item].
//  If coll is a list, prepends else appends to coll.
function conj_BANG(coll) {
  let xs = Array.prototype.slice.call(arguments, 1);
  return (function() {
    let c = (coll || vector());
    for (let ____coll = xs, ____index = 0, ____end = count(____coll), ____break = false; ((!____break) && (____index < ____end)); ____index = (____index + 1)) {
      let x = ____coll[____index];
      if( (Array.isArray(c)) ) {
        if (list_QMRK(c)) {
          c.unshift(x);
        } else {
          c.push(x)
        }
      } else {
        if (set_QMRK(c)) {
          c.add(x);
        } else {
          if (map_QMRK(c)) {
            c.set(x[0], x[1]);
          } else {
            if (true) {
              throw Error(vector("Cannot conj to: ", typeof (c)).join(""));
            }
          }
        }
      }
    }
    return c;
  }).call(this);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [conj] in file: stdlib.ky, line: 1377
/* {"tag" Any} */
//Like conj! but returns a new collection
function conj(coll) {
  let xs = Array.prototype.slice.call(arguments, 1);
  let c = (nichts_QMRK(coll) ?
    vector() :
    (list_QMRK(coll) ?
      into(list(), coll) :
      (vector_QMRK(coll) ?
        into(vector(), coll) :
        ((Array.isArray(coll)) ?
          Array.prototype.slice.call(coll) :
          (map_QMRK(coll) ?
            new Map(coll.entries()) :
            (set_QMRK(coll) ?
              new Set(coll.values()) :
              null))))));
  return (c ?
    conj_BANG.apply(this, vector(c).concat(xs)) :
    null);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [disj!] in file: stdlib.ky, line: 1399
//disj[oin]. Returns a set without these keys
function disj_BANG(coll) {
  let xs = Array.prototype.slice.call(arguments, 1);
  if (set_QMRK(coll)) {
    xs.forEach(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return coll.delete(____args[0]);
    });
  }
  return coll;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [disj] in file: stdlib.ky, line: 1408
//disj[oin]. Returns a new set without these keys
function disj(coll) {
  let xs = Array.prototype.slice.call(arguments, 1);
  let s2 = new Set(xs);
  return new Set(((!set_QMRK(coll)) ?
    vector() :
    (Array.from(coll.values()) || vector()).filter(function() {
      let ____args = Array.prototype.slice.call(arguments);
      return (!s2.has(____args[0]));
    })));
}
////////////////////////////////////////////////////////////////////////////////
//fn: [pop!] in file: stdlib.ky, line: 1419
/* {"tag" Array} */
//Removes the first element if list,
//  else removes the last element,
//  returning the element
//  and the altered collection
function pop_BANG(coll) {
  return ((Array.isArray(coll)) ?
    (function() {
      let r = (list_QMRK(coll) ?
        coll.shift() :
        coll.pop());
      return vector(r, coll);
    }).call(this) :
    null);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [pop] in file: stdlib.ky, line: 1433
/* {"tag" Array} */
//Like pop! but returns a new collection
function pop(coll) {
  return ((Array.isArray(coll)) ?
    (function() {
      let r = (list_QMRK(coll) ?
        coll[0] :
        last(coll));
      return vector(r, (list_QMRK(coll) ?
        coll.slice(1) :
        coll.slice(0, -1)));
    }).call(this) :
    null);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [wrap-str] in file: stdlib.ky, line: 1447
//Prepend and append strings to the object.
function wrap_DASH_str(obj, start, end) {
  return vector(start, obj, end).join("");
}
////////////////////////////////////////////////////////////////////////////////
//fn: [getIndex] in file: stdlib.ky, line: 1455
//Get the item by indexing.
function getIndex(obj, pos) {
  return ((Array.isArray(obj)) ?
    obj[pos] :
    undefined);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [getProp] in file: stdlib.ky, line: 1464
/* {"tag" Any} */
//If prop is a string, returns the value of
//  this object property, obeying the own? flag,
//  unless if object is a Map, returns value of
//  the key. Otherwise, return the value at the
//  index of the array.
function getProp(obj, prop) {
  let GS__2 = Array.prototype.slice.call(arguments, 2);
  let own_QMRK = getIndex(GS__2, 0);
  return (map_QMRK(obj) ?
    obj.get(prop) :
    (nichts_QMRK(obj) ?
      null :
      (true ?
        (function() {
          (
          own_QMRK = opt_QMRK__QMRK(own_QMRK, true));
          return ((((typeof (prop) == "string")) || ((typeof (prop) == "number"))) ?
            ((own_QMRK && ((typeof (prop) == "string")) && (!obj.hasOwnProperty(prop))) ?
              undefined :
              obj[prop]) :
            undefined);
        }).call(this) :
        null)));
}
////////////////////////////////////////////////////////////////////////////////
//fn: [prn] in file: stdlib.ky, line: 1489
/* {"tag" String} */
//Print data as string - use to dump an AST node
function prn(obj) {
  let GS__3 = Array.prototype.slice.call(arguments, 1);
  let r_QMRK = getIndex(GS__3, 0);
  let f = no_DASH_cref();
  if (complex_QMRK(obj)) {
    if (true) {
      (
      obj = f(null, obj));
    }
  }
  return ((!obj) ?
    "" :
    prn_STAR(obj, opt_QMRK__QMRK(r_QMRK, true), f));
}
////////////////////////////////////////////////////////////////////////////////
//fn: [prnArr*] in file: stdlib.ky, line: 1502
//Print an array
function prnArr_STAR(obj, r_QMRK, f) {
  return (obj || vector()).map(function(v, i) {
    let x = f(i, v);
    return prn_STAR(opt_QMRK__QMRK(x, null), r_QMRK, f);
  }).join(" ");
}
////////////////////////////////////////////////////////////////////////////////
//fn: [prn*] in file: stdlib.ky, line: 1513
//Internal print
function prn_STAR(obj, r_QMRK, func) {
  let pfx = function() {
    let ____args = Array.prototype.slice.call(arguments);
    return prn_STAR(____args[0], r_QMRK, func);
  };
  let parr = ((Array.isArray(obj)) ?
    function() {
      let ____args = Array.prototype.slice.call(arguments);
      return wrap_DASH_str(prnArr_STAR(obj, r_QMRK, func), ____args[0], ____args[1]);
    } :
    null);
  return (atom_QMRK(obj) ?
    wrap_DASH_str(pfx(obj.value), "(atom ", ")") :
    ((obj instanceof core.SValue) ?
      obj.value :
      (map_QMRK(obj) ?
        (function() {
          let acc = vector();
          obj.forEach(function(v, k) {
            (
            v = func(k, v));
            return ((!((typeof (v) == "undefined"))) ?
              acc.push(vector(pfx(k), " ", pfx(v)).join("")) :
              null);
          });
          acc.join(",");
          return wrap_DASH_str(acc, "{", "}");
        }).call(this) :
        (set_QMRK(obj) ?
          (function() {
            let acc = vector();
            obj.forEach(function(v, k) {
              (
              v = func(k, v));
              return ((!((typeof (v) == "undefined"))) ?
                acc.push(pfx(v)) :
                null);
            });
            acc.join(" ");
            return wrap_DASH_str(acc, "#{", "}");
          }).call(this) :
          (list_QMRK(obj) ?
            parr("(list ", ")") :
            ((Array.isArray(obj)) ?
              parr("(vec ", ")") :
              (((typeof (obj) == "string")) ?
                (r_QMRK ?
                  quote_DASH_str(obj) :
                  obj) :
                (((obj === null)) ?
                  "nil" :
                  (((typeof (obj) == "undefined")) ?
                    "undefined" :
                    (object_QMRK(obj) ?
                      (function() {
                        let acc = vector();
                        let keys = Object.keys(obj);
                        keys.forEach(function(k, v) {
                          (
                          v = func(k, getProp(obj, k)));
                          return ((!((typeof (v) == "undefined"))) ?
                            acc.push(vector(pfx(k), " ", pfx(v)).join("")) :
                            null);
                        });
                        acc.join(",");
                        return wrap_DASH_str(acc, "(js-obj ", ")");
                      }).call(this) :
                      (true ?
                        vector(obj).join("") :
                        null)))))))))));
}
////////////////////////////////////////////////////////////////////////////////
//fn: [symbol?] in file: stdlib.ky, line: 1567
//Check if a symbol
function symbol_QMRK(obj) {
  return (obj instanceof Symbol);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [symbol] in file: stdlib.ky, line: 1575
/* {"tag" Symbol} */
//Create a new Symbol
function symbol(name) {
  return new Symbol(name);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [keyword?] in file: stdlib.ky, line: 1583
//Check if a keyword
function keyword_QMRK(obj) {
  return (obj instanceof Keyword);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [keyword] in file: stdlib.ky, line: 1591
/* {"tag" Keyword} */
//Create a new Keyword
function keyword(name) {
  return new Keyword(name);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [keyword->symbol] in file: stdlib.ky, line: 1599
/* {"tag" Symbol} */
//Convert a Keyword to Symbol
function keyword_DASH__GT_symbol(k) {
  let s = new Symbol(vector(k).join(""));
  (s["source"] = k.source, s["line"] = k.line, s["column"] = k.column);
  return s;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [atom?] in file: stdlib.ky, line: 1612
//Check if an Atom
function atom_QMRK(atm) {
  return (atm instanceof Atom);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [atom] in file: stdlib.ky, line: 1620
/* {"tag" Atom} */
//Create a new Atom
function atom(val) {
  return new Atom(val);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [reset!] in file: stdlib.ky, line: 1628
//Set a new value to the Atom
function reset_BANG(a, v) {
  return (function() {
    (
    a["value"] = v);
    return null;
  }).call(this);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [objClass] in file: stdlib.ky, line: 1636
//
function objClass(obj) {
  return (obj ?
    obj.constructor :
    null);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [sort!] in file: stdlib.ky, line: 1644
//Returns a sorted sequence of the items in coll.
//  If no comparator is supplied, uses compare
function sort_BANG(comp, coll) {
  return (((typeof (comp) == "function")) ?
    coll.sort(comp) :
    comp.sort());
}
////////////////////////////////////////////////////////////////////////////////
//fn: [deref] in file: stdlib.ky, line: 1653
/* {"tag" Any} */
//Get value inside the Atom
function deref(a) {
  return a.value;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [swap!] in file: stdlib.ky, line: 1661
/* {"tag" Any} */
//Change value inside the Atom, returning the new value
function swap_BANG(a, f) {
  let xs = Array.prototype.slice.call(arguments, 2);
  (
  a["value"] = f.apply(this, vector(a.value).concat(xs)));
  return getProp(a, "value");
}
////////////////////////////////////////////////////////////////////////////////
//fn: [complex?] in file: stdlib.ky, line: 1671
//Check x is an array or js object.
function complex_QMRK(x) {
  return ((Array.isArray(x)) || object_QMRK(x) || map_QMRK(x) || set_QMRK(x));
}
////////////////////////////////////////////////////////////////////////////////
//fn: [simple?] in file: stdlib.ky, line: 1681
//Check if x is a primitive value type
function simple_QMRK(obj) {
  return (((typeof (obj) == "undefined")) || ((obj === null)) || ((obj === false)) || ((obj === true)) || ((typeof (obj) == "string")) || ((typeof (obj) == "number")));
}
////////////////////////////////////////////////////////////////////////////////
//fn: [sequential?] in file: stdlib.ky, line: 1691
//Check if coll implements Sequential
function sequential_QMRK(arr) {
  return (list_QMRK(arr) || vector_QMRK(arr) || (Array.isArray(arr)));
}
////////////////////////////////////////////////////////////////////////////////
//fn: [eqSets?] in file: stdlib.ky, line: 1699
//
function eqSets_QMRK(s1, s2) {
  let ok_QMRK = true;
  if( (s1.size === s2.size) ) {
    if (true) {
      s1.forEach(function(v, k) {
        return ((!s2.has(v)) ?
          (ok_QMRK = false) :
          null);
      });
    }
  }
  return ok_QMRK;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [eqMaps?] in file: stdlib.ky, line: 1710
//
function eqMaps_QMRK(m1, m2) {
  let ok_QMRK = true;
  if( (m1.size == m2.size) ) {
    if (true) {
      m1.forEach(function(v, k) {
        return ((!eq_QMRK(m2.get(k), v)) ?
          (ok_QMRK = false) :
          null);
      });
    }
  }
  return ok_QMRK;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [eqArrs?] in file: stdlib.ky, line: 1721
//
function eqArrs_QMRK(a1, a2) {
  let ok_QMRK = true;
  if( (a1.length == a2.length) ) {
    if (true) {
      a1.forEach(function(v, k) {
        return ((!eq_QMRK(a2[k], v)) ?
          (ok_QMRK = false) :
          null);
      });
    }
  }
  return ok_QMRK;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [eqObjs?] in file: stdlib.ky, line: 1732
//
function eqObjs_QMRK(o1, o2) {
  let ok_QMRK = true;
  let k1 = Object.keys(o1);
  let k2 = Object.keys(o2);
  if (eqSets_QMRK(new Set(k1), new Set(k2))) {
    if (true) {
      k1.forEach(function(k) {
        return ((!eq_QMRK(getProp(o1, k), getProp(o2, k))) ?
          (ok_QMRK = false) :
          null);
      });
    }
  }
  return ok_QMRK;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [eq?] in file: stdlib.ky, line: 1747
//Check if both are equal
function eq_QMRK(a, b) {
  return ((map_QMRK(a) && map_QMRK(b)) ?
    eqMaps_QMRK(a, b) :
    ((set_QMRK(a) && set_QMRK(b)) ?
      eqSets_QMRK(a, b) :
      (((Array.isArray(a)) && (Array.isArray(b))) ?
        eqArrs_QMRK(a, b) :
        (((rtti_QMRK(a, "[object RegExp]")) && (rtti_QMRK(b, "[object RegExp]"))) ?
          (a.value === b.value) :
          ((symbol_QMRK(a) && symbol_QMRK(b)) ?
            (a.value === b.value) :
            ((keyword_QMRK(a) && keyword_QMRK(b)) ?
              (a.value === b.value) :
              ((object_QMRK(a) && object_QMRK(b)) ?
                eqObjs_QMRK(a, b) :
                (true ?
                  (a === b) :
                  null))))))));
}
////////////////////////////////////////////////////////////////////////////////
//fn: [object?] in file: stdlib.ky, line: 1784
//Check if a js object
function object_QMRK(obj) {
  return ((!(((obj === null)) || map_QMRK(obj) || set_QMRK(obj) || (rtti_QMRK(obj, "[object RegExp]")) || (Array.isArray(obj)))) ?
    rtti_QMRK(obj, "[object Object]") :
    null);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [last] in file: stdlib.ky, line: 1796
/* {"tag" Any} */
//The last element
function last(coll) {
  return (((Array.isArray(coll)) || ((typeof (coll) == "string"))) ?
    ((coll.length > 0) ?
      coll[(coll.length - 1)] :
      null) :
    null);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [into-map] in file: stdlib.ky, line: 1805
//Copy stuff into a map.
function into_DASH_map(to, coll) {
  let len = count(coll);
  if( (!((0 == mod(len, 2)))) ) {
    throw Error("into-map expects even args");
  } else {
    null
  }
  if (map_QMRK(coll)) {
    coll.forEach(function(v, k) {
      return to.set(k, v);
    });
  } else {
    if (set_QMRK(coll)) {
      for (let ____coll = coll.values(), i = 0, ____end = count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 2)) {
        let v = ____coll[i];
        to.set(____coll[i], ____coll[i + 1]);
      }
    } else {
      if( (Array.isArray(coll)) ) {
        for (let ____coll = coll, i = 0, ____end = count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 2)) {
          let v = ____coll[i];
          to.set(____coll[i], ____coll[i + 1]);
        }
      } else {
        if (true) {
          throw Error("Bad source data for into-map");
        }
      }
    }
  }
  return to;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [into-set] in file: stdlib.ky, line: 1826
//Copy stuff into a set.
function into_DASH_set(to, coll) {
  if (set_QMRK(coll)) {
    for (let ____coll = coll.values(), ____index = 0, ____end = count(____coll), ____break = false; ((!____break) && (____index < ____end)); ____index = (____index + 1)) {
      let v = ____coll[____index];
      to.add(v);
    }
  } else {
    if( (Array.isArray(coll)) ) {
      for (let ____coll = coll, ____index = 0, ____end = count(____coll), ____break = false; ((!____break) && (____index < ____end)); ____index = (____index + 1)) {
        let v = ____coll[____index];
        to.add(v);
      }
    } else {
      if (true) {
        throw Error("Bad source data for into-set");
      }
    }
  }
  return to;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [into-arr] in file: stdlib.ky, line: 1842
//Copy stuff into a list or vec.
function into_DASH_arr(to, coll) {
  if (map_QMRK(coll)) {
    coll.forEach(function(v, k) {
      return to.push(vector(k, v));
    });
  } else {
    if (set_QMRK(coll)) {
      for (let ____coll = coll.values(), ____index = 0, ____end = count(____coll), ____break = false; ((!____break) && (____index < ____end)); ____index = (____index + 1)) {
        let v = ____coll[____index];
        to.push(v);
      }
    } else {
      if( (Array.isArray(coll)) ) {
        for (let ____coll = coll, ____index = 0, ____end = count(____coll), ____break = false; ((!____break) && (____index < ____end)); ____index = (____index + 1)) {
          let v = ____coll[____index];
          to.push(v);
        }
      } else {
        if (true) {
          throw Error("Bad source data for into-set");
        }
      }
    }
  }
  return to;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [into] in file: stdlib.ky, line: 1860
//Returns a new coll consisting of to-coll with all of the items of
//from-coll conjoined.
function into(to, coll) {
  if( (Array.isArray(to)) ) {
    into_DASH_arr(to, coll);
  } else {
    if (map_QMRK(to)) {
      into_DASH_map(to, coll);
    } else {
      if (set_QMRK(to)) {
        into_DASH_set(to, coll);
      } else {
        if (true) {
          throw Error("Unsupported type for into()");
        }
      }
    }
  }
  return to;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [map?] in file: stdlib.ky, line: 1878
//Check if a Map
function map_QMRK(obj) {
  return (obj instanceof Map);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [set?] in file: stdlib.ky, line: 1885
//Check if a Set
function set_QMRK(obj) {
  return (obj instanceof Set);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [list?] in file: stdlib.ky, line: 1892
//Check if a List
function list_QMRK(obj) {
  return (obj instanceof SPair);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [list] in file: stdlib.ky, line: 1899
/* {"tag" SPair} */
//Create a List
function list() {
  let xs = Array.prototype.slice.call(arguments, 0);
  return (function() {
    let o = new SPair();
    xs.forEach(function(z) {
      return o.push(z);
    });
    return o;
  }).call(this);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [vector] in file: stdlib.ky, line: 1908
/* {"tag" DArray} */
//Create a Vector
function vector() {
  let xs = Array.prototype.slice.call(arguments, 0);
  return (function() {
    let o = new DArray();
    xs.forEach(function(z) {
      return o.push(z);
    });
    return o;
  }).call(this);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [vector?] in file: stdlib.ky, line: 1917
//Check if a Vector
function vector_QMRK(v) {
  return (v instanceof DArray);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [object] in file: stdlib.ky, line: 1925
/* {"tag" Object} */
//Create a new js object
function object() {
  let xs = Array.prototype.slice.call(arguments, 0);
  return (((0 != mod(xs.length, 2))) ?
    (function() {
      throw Error("Invalid arity for object");
    }).call(this) :
    (function() {
      let ret = new Object();
      for (let ____coll = null, i = 0, ____end = count(xs), ____break = false; ((!____break) && (i < ____end)); i = (i + 2)) {
        (
        ret[xs[i]] = xs[i + 1]);
      }
      return ret;
    }).call(this));
}
////////////////////////////////////////////////////////////////////////////////
//fn: [seq] in file: stdlib.ky, line: 1936
/* {"tag" Array} */
//Returns a sequence
function seq(obj) {
  return (function() {
    let out = list();
    let a = (((typeof (obj) == "string")) ?
      obj.split("") :
      ((Array.isArray(obj)) ?
        obj.slice(0) :
        (set_QMRK(obj) ?
          Array.from(obj.values()) :
          null)));
    if (a) {
      a.forEach(function(v) {
        return out.push(v);
      });
    } else {
      if (map_QMRK(obj)) {
        obj.forEach(function(v, k) {
          return out.push(list(k, v));
        });
      } else {
        if (object_QMRK(obj)) {
          Object.keys(obj).forEach(function(k) {
            return out.push(list(k, obj[k]));
          });
        } else {
          null
        }
      }
    }
    return out;
  }).call(this);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [rseq] in file: stdlib.ky, line: 1954
//Returns a seq of the items in coll in reverse order. If rev is empty returns nil.
function rseq(coll) {
  return seq(coll).reverse();
}
////////////////////////////////////////////////////////////////////////////////
//fn: [contains?] in file: stdlib.ky, line: 1961
//Check if item is inside
function contains_QMRK(coll, x) {
  return (((Array.isArray(coll)) || ((typeof (coll) == "string"))) ?
    coll.includes(x) :
    (set_QMRK(coll) ?
      coll.has(x) :
      (map_QMRK(coll) ?
        coll.has(x) :
        (object_QMRK(coll) ?
          coll.hasOwnProperty(x) :
          null))));
}
////////////////////////////////////////////////////////////////////////////////
//fn: [nichts?] in file: stdlib.ky, line: 1973
//Check if object is either null of undefined
function nichts_QMRK(obj) {
  return (((typeof (obj) == "undefined")) || ((obj === null)));
}
////////////////////////////////////////////////////////////////////////////////
//fn: [some?] in file: stdlib.ky, line: 1980
//Check if object is defined and not null
function some_QMRK(obj) {
  return (!nichts_QMRK(obj));
}
////////////////////////////////////////////////////////////////////////////////
//fn: [count] in file: stdlib.ky, line: 1988
/* {"tag" Integer} */
//Count the number of elements inside
function count(coll) {
  return (coll ?
    ((map_QMRK(coll) || set_QMRK(coll)) ?
      coll.size :
      ((((typeof (coll) == "string")) || (Array.isArray(coll))) ?
        coll :
        Object.keys(coll)).length) :
    0);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [hash-map] in file: stdlib.ky, line: 2000
/* {"tag" Map} */
//Create a map from these key values
function hash_DASH_map() {
  let xs = Array.prototype.slice.call(arguments, 0);
  let ret = new Map();
  for (let ____coll = null, i = 0, ____end = count(xs), ____break = false; ((!____break) && (i < ____end)); i = (i + 2)) {
    ret.set(xs[i], xs[i + 1]);
  }
  return ret;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [hash-set] in file: stdlib.ky, line: 2009
/* {"tag" Set} */
//Create a set from these values
function hash_DASH_set() {
  let xs = Array.prototype.slice.call(arguments, 0);
  let ret = new Set();
  for (let ____coll = null, i = 0, ____end = count(xs), ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
    ret.add(xs[i]);
  }
  return ret;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [concat*] in file: stdlib.ky, line: 2018
/* {"tag" Array} */
//Add many to this collection
function concat_STAR(coll) {
  let xs = Array.prototype.slice.call(arguments, 1);
  return (coll ?
    coll.concat.apply(coll, xs) :
    null);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [repeat-every] in file: stdlib.ky, line: 2025
/* {"tag" Array} */
//
function repeat_DASH_every(coll, start, step) {
  let ret = list();
  for (let ____coll = coll, ____index = start, ____end = count(____coll), ____break = false; ((!____break) && (____index < ____end)); ____index = (____index + step)) {
    let e = ____coll[____index];
    ret.push(e);
  }
  return ret;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [evens] in file: stdlib.ky, line: 2033
/* {"tag" Array} */
//Collect every 2nd item starting at 0
function evens(coll) {
  return repeat_DASH_every(coll, 0, 2);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [odds] in file: stdlib.ky, line: 2040
/* {"tag" Array} */
//Collect every 2nd item starting at 1
function odds(coll) {
  return repeat_DASH_every(coll, 1, 2);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [mod] in file: stdlib.ky, line: 2047
/* {"tag" Integer} */
//Modulo
function mod(x, N) {
  return ((x < 0) ?
    (x - (-1 * (N + (Math.floor(((-1 * x) / N)) * N)))) :
    (x % N));
}
////////////////////////////////////////////////////////////////////////////////
//fn: [partition] in file: stdlib.ky, line: 2056
/* {"tag" Array} */
//Returns a sequence of lists of n items each.
function partition(n, coll) {
  return (function() {
    let _x_ = undefined;
    let recur = undefined;
    let _f_ = function(ret, GS__4) {
      let x = getIndex(GS__4, 0);
      let y = getIndex(GS__4, 1);
      if (not_DASH_empty(x)) {
        ret.push(x);
      }
      return ((0 == count(y)) ?
        ret :
        recur(ret, split_DASH_seq(y, n)));
    };
    let _r_ = _f_;
    (recur = function() {
      (
      _x_ = arguments);
      if (_r_) {
        for (_r_ = undefined; _r_ === undefined;) {
          _r_ = _f_.apply(this, _x_);
        }
        return _r_;
      }
      return undefined;
    });
    return recur(list(), split_DASH_seq(coll, n));
  })(this);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [split] in file: stdlib.ky, line: 2068
//Splits string on a sep or regular expression.  Optional argument limit is
//the maximum number of splits. Returns vector of the splits.
function split(s, re) {
  let GS__5 = Array.prototype.slice.call(arguments, 2);
  let limit = getIndex(GS__5, 0);
  return (((typeof (limit) != "undefined")) ?
    s.split(re, limit) :
    s.split(re));
}
////////////////////////////////////////////////////////////////////////////////
//fn: [split-str] in file: stdlib.ky, line: 2077
//Returns a sequence of strings of n characters each.
function split_DASH_str(n, string) {
  let ret = list();
  for (let ____coll = null, i = 0, ____end = count(string), ____break = false; ((!____break) && (i < ____end)); i = (i + n)) {
    ret.push(string.substr(i, n));
  }
  return ret;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [interleave] in file: stdlib.ky, line: 2086
/* {"tag" Array} */
//Returns a seq of the first item in each coll, then the second, etc
function interleave(c1, c2) {
  let cz = ((c2.length < c1.length) ?
    c2.length :
    c1.length);
  let ret = list();
  for (let ____coll = null, i = 0, ____end = cz, ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
    ret.push(c1[i], c2[i]);
  }
  return ret;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [zipmap] in file: stdlib.ky, line: 2097
/* {"tag" Map} */
//Returns an object with the keys mapped to the corresponding vals
function zipmap(keys, vals) {
  let ret = new Map();
  let cz = ((keys.length < vals.length) ?
    keys.length :
    vals.length);
  for (let ____coll = null, i = 0, ____end = cz, ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
    assoc_BANG(ret, keys[i], vals[i]);
  }
  return ret;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [zipobj] in file: stdlib.ky, line: 2109
/* {"tag" Map} */
//Returns an object with the keys mapped to the corresponding vals
function zipobj(keys, vals) {
  let ret = new Object();
  let cz = ((keys.length < vals.length) ?
    keys.length :
    vals.length);
  for (let ____coll = null, i = 0, ____end = cz, ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
    assoc_BANG(ret, vector(keys[i]).join(""), vals[i]);
  }
  return ret;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [extendAttr] in file: stdlib.ky, line: 2121
/* {"tag" Object} */
//
function extendAttr(obj, attr) {
  let GS__6 = Array.prototype.slice.call(arguments, 2);
  let flags = getIndex(GS__6, 0);
  (
  flags = opt_QMRK__QMRK(flags, object("enumerable", false, "writable", true)));
  Object.defineProperty(obj, attr, flags);
  return obj;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [cons] in file: stdlib.ky, line: 2130
//Returns a new seq where x is the first element and seq is the rest.
function cons(x, coll) {
  return ((Array.isArray(coll)) ?
    (function() {
      return list(x).concat(coll);
    }).call(this) :
    null);
}
var gensym_DASH_counter = 0;
////////////////////////////////////////////////////////////////////////////////
//fn: [gensym] in file: stdlib.ky, line: 2140
/* {"tag" Symbol} */
//Generates next random symbol
function gensym() {
  let GS__7 = Array.prototype.slice.call(arguments, 0);
  let pfx = getIndex(GS__7, 0);
  return (function() {
    let v = gensym_DASH_counter;
    (1 + gensym_DASH_counter);
    return symbol(vector(opt_QMRK__QMRK(pfx, "GS__"), v).join(""));
  }).call(this);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [assoc!] in file: stdlib.ky, line: 2149
/* {"tag" Any} */
//
function assoc_BANG(obj) {
  let xs = Array.prototype.slice.call(arguments, 1);
  if (obj) {
    if (true) {
      for (let ____coll = xs, i = 0, ____end = count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 2)) {
        let k = ____coll[i];
        let v = xs[(1 + i)];
        if (map_QMRK(obj)) {
          obj.set(k, v);
        } else {
          if (object_QMRK(obj)) {
            obj[k] = v;
          } else {
            null
          }
        }
      }
    }
  }
  return obj;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [dissoc!] in file: stdlib.ky, line: 2161
/* {"tag" Any} */
//
function dissoc_BANG(obj) {
  let xs = Array.prototype.slice.call(arguments, 1);
  if (obj) {
    if (true) {
      for (let GS__10 = 0, GS__8 = true, GS__9 = xs, ____sz = count(GS__9), ____break = false; (!____break && GS__8 && (GS__10 < ____sz)); ++GS__10) {
        let k = GS__9[GS__10];
        if (map_QMRK(obj)) {
          obj.delete(k);
        } else {
          if (object_QMRK(obj)) {
            delete obj[k];
          } else {
            null
          }
        }
      }
    }
  }
  return obj;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [truthy?] in file: stdlib.ky, line: 2172
//LISP truthy
function truthy_QMRK(a) {
  return (!falsy_QMRK(a));
}
////////////////////////////////////////////////////////////////////////////////
//fn: [falsy?] in file: stdlib.ky, line: 2179
//LISP falsy
function falsy_QMRK(a) {
  return (((a === null)) || ((a === false)));
}
////////////////////////////////////////////////////////////////////////////////
//fn: [flatten] in file: stdlib.ky, line: 2186
//Flatten an array
function flatten(xs) {
  return (xs || vector()).reduce(function(acc, v) {
    return acc.concat(v);
  }, list());
}
////////////////////////////////////////////////////////////////////////////////
//fn: [identity] in file: stdlib.ky, line: 2193
//Returns its argument.
function identity(x) {
  return x;
}
const monad_DASH_identity = (function() {
  let bind = null;
  let unit = null;
  let zero = null;
  let plus = null;
  return (function() {
    let bind = function(mv, mf) {
      return mf(mv);
    };
    let unit = function() {
      let ____args = Array.prototype.slice.call(arguments);
      return ____args[0];
    };
    return object("bind", bind, "unit", unit, "zero", zero, "plus", plus);
  }).call(this);
}).call(this);
const monad_DASH_maybe = (function() {
  let bind = null;
  let unit = null;
  let zero = null;
  let plus = null;
  return (function() {
    let bind = function(mv, mf) {
      return ((!((mv === null))) ?
        mf(mv) :
        null);
    };
    let unit = function() {
      let ____args = Array.prototype.slice.call(arguments);
      return ____args[0];
    };
    let zero = null;
    return object("bind", bind, "unit", unit, "zero", zero, "plus", plus);
  }).call(this);
}).call(this);
const monad_DASH_list = (function() {
  let bind = null;
  let unit = null;
  let zero = null;
  let plus = null;
  return (function() {
    let bind = function(mv, mf) {
      return flatten((mv || vector()).map(mf));
    };
    let unit = function() {
      let ____args = Array.prototype.slice.call(arguments);
      return vector().concat(____args[0]);
    };
    let zero = vector();
    let plus = function() {
      let ____args = Array.prototype.slice.call(arguments);
      return flatten(____args);
    };
    return object("bind", bind, "unit", unit, "zero", zero, "plus", plus);
  }).call(this);
}).call(this);
const monad_DASH_state = (function() {
  let bind = null;
  let unit = null;
  let zero = null;
  let plus = null;
  return (function() {
    let bind = function(mv, mf) {
      return function(state) {
        return (function() {
          let GS__11 = mv(state);
          let value = getIndex(GS__11, 0);
          let newState = getIndex(GS__11, 1);
          return mf(value)(newState);
        }).call(this);
      };
    };
    let unit = function(v) {
      return function() {
        let ____args = Array.prototype.slice.call(arguments);
        return vector(v, ____args[0]);
      };
    };
    return object("bind", bind, "unit", unit, "zero", zero, "plus", plus);
  }).call(this);
}).call(this);
const monad_DASH_continuation = (function() {
  let bind = null;
  let unit = null;
  let zero = null;
  let plus = null;
  return (function() {
    let bind = function(mv, mf) {
      return function(cont) {
        return mv(function(value) {
          return mf(value)(cont);
        });
      };
    };
    let unit = function(value) {
      return function(cont) {
        return cont(value);
      };
    };
    return object("bind", bind, "unit", unit, "zero", zero, "plus", plus);
  }).call(this);
}).call(this);
////////////////////////////////////////////////////////////////////////////////
//fn: [run-monad-continuation] in file: stdlib.ky, line: 2252
//Execute the computation cont
//  in the cont monad and return its result.
function run_DASH_monad_DASH_continuation(cont) {
  return cont(identity);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [quote-str] in file: stdlib.ky, line: 2260
/* {"tag" String} */
//Add quotes around a string
function quote_DASH_str(s) {
  let ch = "";
  let out = "\"";
  for (let ____coll = null, i = 0, ____end = count(s), ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
    (
    ch = s.charAt(i));
    if( (ch === "\"") ) {
      (
      out += "\\\"");
    } else {
      if( (ch === "\n") ) {
        (
        out += "\\n");
      } else {
        if( (ch === "\t") ) {
          (
          out += "\\t");
        } else {
          if( (ch === "\f") ) {
            (
            out += "\\f");
          } else {
            if( (ch === "\r") ) {
              (
              out += "\\r");
            } else {
              if( (ch === "\v") ) {
                (
                out += "\\v");
              } else {
                if( (ch === "\\") ) {
                  (
                  out += (("u" === s.charAt((1 + i))) ?
                    ch :
                    "\\\\"));
                } else {
                  if (true) {
                    (
                    out += ch);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return (out += "\"");
}
////////////////////////////////////////////////////////////////////////////////
//fn: [unquote-str] in file: stdlib.ky, line: 2279
/* {"tag" String} */
//Removes quotes around a string
function unquote_DASH_str(s) {
  return ((((typeof (s) == "string")) && s.startsWith("\"") && s.endsWith("\"")) ?
    (function() {
      let out = "";
      (s = s.slice(1, -1));
      for (let ____coll = null, i = 0, ____end = count(s), ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
        let nx = undefined;
        let ch = s.charAt(i);
        if( (ch === "\\") ) {
          if (true) {
            ++i;
            (
            nx = s.charAt(i));
            if( (nx === "\"") ) {
              (
              out += "\"");
            } else {
              if( (nx === "\\") ) {
                (
                out += "\\");
              } else {
                if( (nx === "n") ) {
                  (
                  out += "\n");
                } else {
                  if( (nx === "t") ) {
                    (
                    out += "\t");
                  } else {
                    if( (nx === "f") ) {
                      (
                      out += "\f");
                    } else {
                      if( (nx === "v") ) {
                        (
                        out += "\v");
                      } else {
                        if( (nx === "r") ) {
                          (
                          out += "\r");
                        } else {
                          if (true) {
                            if (true) {
                              (
                              out += ch);
                              --i;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          (
          out += ch)
        }
      }
      return out;
    }).call(this) :
    s);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [esc-xml] in file: stdlib.ky, line: 2307
/* {"tag" String} */
//Escape XML special chars
function esc_DASH_xml(s) {
  let out = "";
  for (let GS__14 = 0, GS__12 = true, GS__13 = s, ____sz = count(GS__13), ____break = false; (!____break && GS__12 && (GS__14 < ____sz)); ++GS__14) {
    let c = GS__13[GS__14];
    if( (c === "&") ) {
      (
      c = "&amp;");
    } else {
      if( (c === ">") ) {
        (
        c = "&gt;");
      } else {
        if( (c === "<") ) {
          (
          c = "&lt;");
        } else {
          if( (c === "\"") ) {
            (
            c = "&quot;");
          } else {
            if( (c === "'") ) {
              (
              c = "&apos;");
            } else {
              null
            }
          }
        }
      }
    }
    (out += c);
  }
  return out;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [split-seq] in file: stdlib.ky, line: 2323
/* {"tag" Array} */
//Split a collection into 2 parts
function split_DASH_seq(coll, cnt) {
  return ((cnt < count(coll)) ?
    vector(Array.prototype.slice.call(coll, 0, cnt), Array.prototype.slice.call(coll, cnt)) :
    vector(Array.prototype.slice.call(coll, 0), vector()));
}
////////////////////////////////////////////////////////////////////////////////
//fn: [select-keys] in file: stdlib.ky, line: 2331
/* {"tag" Map} */
//Get a subset of keys
function select_DASH_keys(coll, keys) {
  return (seq(keys) || vector()).reduce(function(acc, n) {
    return assoc_BANG(acc, n, coll.get(n));
  }, new Map());
}
////////////////////////////////////////////////////////////////////////////////
//fn: [do-update-in!] in file: stdlib.ky, line: 2342
//
function do_DASH_update_DASH_in_BANG(coll, n, func, args, err) {
  let cur = (((typeof (n) == "number")) ?
    (((Array.isArray(coll)) && (n < coll.length)) ?
      coll[n] :
      err(n)) :
    (true ?
      coll.get(n) :
      null));
  let v = func.apply(this, cons(cur, args));
  return assoc_BANG(coll, n, v);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [update-in!] in file: stdlib.ky, line: 2356
/* {"tag" Map} */
//'Updates' a value in a nested associative structure, where ks is a
//sequence of keys and f is a function that will take the old value
//and any supplied args and return the new value, and returns a new
//nested structure.  If any levels do not exist, hash-maps will be
//created.
function update_DASH_in_BANG(coll, keys, func) {
  let xs = Array.prototype.slice.call(arguments, 3);
  let err = function() {
    let ____args = Array.prototype.slice.call(arguments);
    return (function() {
      throw Error(vector("update-in! failed, bad nested keys: ", ____args[0]).join(""));
    }).call(this);
  };
  let root = coll;
  let m = null;
  let end = (keys.length - 1);
  for (let ____coll = keys, i = 0, ____end = count(____coll), ____break = false; ((!____break) && (i <= end)); i = (i + 1)) {
    let n = ____coll[i];
    if( (i == end) ) {
      do_DASH_update_DASH_in_BANG(root, n, func, xs, err);
    } else {
      if(( (typeof (n) == "number") )) {
        if( (!((Array.isArray(root)) && (n < root.length))) ) {
          err(n);
        } else {
          (
          root = root[n])
        }
      } else {
        if (true) {
          if (true) {
            (
            m = root.get(n));
            if(( (typeof (m) == "undefined") )) {
              if (true) {
                (
                m = new Map());
                assoc_BANG(root, n, m);
              }
            }
            if( (!map_QMRK(m)) ) {
              err(n);
            } else {
              null
            }
            (root = m);
          }
        }
      }
    }
  }
  return coll;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [get-in] in file: stdlib.ky, line: 2386
/* {"tag" Any} */
//Returns the value in a nested associative structure,
//  where ks is a sequence of keys. Returns nil if the key
//  is not present, or the not-found value if supplied.
function get_DASH_in(coll, keys) {
  let root = coll;
  let ret = null;
  let m = null;
  let n = null;
  let end = (keys.length - 1);
  for (let ____coll = keys, i = 0, ____end = count(____coll), ____break = false; ((!____break) && (i <= end)); i = (i + 1)) {
    let n = ____coll[i];
    if(( (typeof (n) == "number") )) {
      if( (!((Array.isArray(root)) && (n < root.length))) ) {
        if (true) {
          (
          ret = null);
          (
          ____break = true);
        }
      } else {
        (root = root[n], ret = root)
      }
    } else {
      if (true) {
        if (true) {
          (root = root.get(n), ret = root);
        }
      }
    }
  }
  return ret;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [merge!] in file: stdlib.ky, line: 2411
//
function merge_BANG(base, m) {
  let ret = (base || new Map());
  let src = (m || new Map());
  if (true) {
    let GS__15 = src;
    let GS__16 = function(v, k) {
      return assoc_BANG(ret, k, v);
    };
    if (object_QMRK(GS__15)) {
      if (true) {
        let GS__17 = GS__15;
        Object.keys(GS__17).forEach(function(p) {
          return GS__16(getProp(GS__17, p), p);
        });
      }
    } else {
      GS__15.forEach(GS__16)
    }
  }
  return ret;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [mix!] in file: stdlib.ky, line: 2420
//
function mix_BANG(base, m) {
  let ret = (base || object());
  let src = (m || object());
  if (true) {
    let GS__18 = src;
    let GS__19 = function(v, k) {
      return (ret[k] = v);
    };
    if (object_QMRK(GS__18)) {
      if (true) {
        let GS__20 = GS__18;
        Object.keys(GS__20).forEach(function(p) {
          return GS__19(getProp(GS__20, p), p);
        });
      }
    } else {
      GS__18.forEach(GS__19)
    }
  }
  return ret;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [merge] in file: stdlib.ky, line: 2429
//Returns a map that consists of the rest of the maps conj-ed onto
//the first.  If a key occurs in more than one map, the mapping from
//the latter (left-to-right) will be the mapping in the result.
function merge() {
  let maps = Array.prototype.slice.call(arguments, 0);
  return (maps || vector()).reduce(function(acc, n) {
    return merge_BANG(acc, n);
  }, new Map());
}
////////////////////////////////////////////////////////////////////////////////
//fn: [mixin] in file: stdlib.ky, line: 2438
//Returns an object that consists of the rest of the objects conj-ed onto
//the first.  If a property occurs in more than one object, the mapping from
//the latter (left-to-right) will be the mapping in the result.
function mixin() {
  let objs = Array.prototype.slice.call(arguments, 0);
  return (objs || vector()).reduce(function(acc, n) {
    return mix_BANG(acc, n);
  }, object());
}
////////////////////////////////////////////////////////////////////////////////
//fn: [fill-array] in file: stdlib.ky, line: 2447
//
function fill_DASH_array(len, v) {
  let ret = vector();
  for (let ____coll = null, x = 0, ____end = len, ____break = false; ((!____break) && (x < ____end)); x = (x + 1)) {
    ret.push((((typeof (v) == "function")) ?
      v(x) :
      v));
  }
  return ret;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [copy-array] in file: stdlib.ky, line: 2456
//
function copy_DASH_array(src, des) {
  let sz = Math.min(count(src), count(des));
  for (let ____coll = null, i = 0, ____end = sz, ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
    (
    des[i] = src[i]);
  }
  return des;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [aclone] in file: stdlib.ky, line: 2466
//Creates a clone of the given JavaScript array.
//  The result is a new array, which is a shallow copy.
function aclone(src) {
  return ((Array.isArray(src)) ?
    src.slice(0) :
    null);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [difference] in file: stdlib.ky, line: 2474
//Return a set that is the first set
//  without elements of the other set.
function difference(a, b) {
  let ret = vector();
  for (let GS__23 = 0, GS__21 = true, GS__22 = a, ____sz = count(GS__22), ____break = false; (!____break && GS__21 && (GS__23 < ____sz)); ++GS__23) {
    let z = GS__22[GS__23];
    if( (!contains_QMRK(b, z)) ) {
      ret.push(z);
    } else {
      null
    }
  }
  return new Set(ret);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [percent] in file: stdlib.ky, line: 2485
/* {"tag" Number} */
//
function percent(numerator, denominator) {
  return (100 * (numerator / denominator));
}
////////////////////////////////////////////////////////////////////////////////
//fn: [to-fixed] in file: stdlib.ky, line: 2492
/* {"tag" String} */
//
function to_DASH_fixed(num, digits) {
  (
  digits = opt_QMRK__QMRK(digits, 2));
  return Number(num).toFixed(digits);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [mapcat] in file: stdlib.ky, line: 2500
//
function mapcat(func, coll) {
  let ret = list();
  return ret.concat.apply(ret, (coll || vector()).map(func));
}
////////////////////////////////////////////////////////////////////////////////
//fn: [ensure-test] in file: stdlib.ky, line: 2510
//
function ensure_DASH_test(cnd, msg) {
  (
  msg = (msg || "test"));
  return (function() {
    try {
      return vector((cnd ?
        "passed:" :
        "FAILED:"), " ", msg).join("");
    } catch (e) {
      return vector("FAILED: ", msg).join("");
    }
  }).call(this);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [ensure-test-thrown] in file: stdlib.ky, line: 2519
//
function ensure_DASH_test_DASH_thrown(expected, error, msg) {
  return (((error === null)) ?
    vector("FAILED: ", msg).join("") :
    (((expected == typeof (error)) || (expected == "any")) ?
      vector("passed: ", msg).join("") :
      vector("FAILED: ", msg).join("")));
}
////////////////////////////////////////////////////////////////////////////////
//fn: [run-test] in file: stdlib.ky, line: 2531
//
function run_DASH_test(test) {
  let GS__24 = Array.prototype.slice.call(arguments, 1);
  let title = getIndex(GS__24, 0);
  (
  title = opt_QMRK__QMRK(title, "test"));
  let now = new Date();
  let results = test();
  let sum = count(results);
  let ok = count((results || vector()).filter(function() {
    let ____args = Array.prototype.slice.call(arguments);
    return ____args[0].startsWith("p");
  }));
  let ps = to_DASH_fixed(percent(ok, sum));
  return vector("+".repeat(78), title, now, "+".repeat(78), results.join("\n"), "=".repeat(78), vector("Passed: ", ok, "/", sum, " [", ps, "%]").join(""), vector("Failed: ", (sum - ok)).join(""), vector("CPU Time: ", (new Date() - now), "ms").join("")).join("\n");
}
var _STAR_ns_DASH_cache_STAR = vector(hash_DASH_map("id", "user", "meta", null));
////////////////////////////////////////////////////////////////////////////////
//fn: [push-nsp] in file: stdlib.ky, line: 2556
//
function push_DASH_nsp(nsp) {
  let GS__25 = Array.prototype.slice.call(arguments, 1);
  let info = getIndex(GS__25, 0);
  return _STAR_ns_DASH_cache_STAR.unshift(hash_DASH_map("id", nsp, "meta", info));
}
////////////////////////////////////////////////////////////////////////////////
//fn: [pop-nsp] in file: stdlib.ky, line: 2563
//
function pop_DASH_nsp() {
  return _STAR_ns_DASH_cache_STAR.shift();
}
////////////////////////////////////////////////////////////////////////////////
//fn: [peek-nsp] in file: stdlib.ky, line: 2570
//
function peek_DASH_nsp() {
  return _STAR_ns_DASH_cache_STAR[0];
}
////////////////////////////////////////////////////////////////////////////////
//fn: [*ns*] in file: stdlib.ky, line: 2578
//
function _STAR_ns_STAR() {
  return (function() {
    let GS__26 = peek_DASH_nsp();
    let n = GS__26;
    return ((((typeof (GS__26) == "undefined")) || ((GS__26 === null))) ?
      null :
      getProp(n, "id"));
  }).call(this);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [min-by] in file: stdlib.ky, line: 2585
//
function min_DASH_by(func, coll) {
  return (not_DASH_empty(coll) ?
    (function() {
      return (coll.slice(1) || vector()).reduce(function(a, b) {
        return ((func(a) < func(b)) ?
          a :
          b);
      }, coll[0]);
    }).call(this) :
    null);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [max-by] in file: stdlib.ky, line: 2593
//
function max_DASH_by(func, coll) {
  return (not_DASH_empty(coll) ?
    (function() {
      return (coll.slice(1) || vector()).reduce(function(a, b) {
        return ((func(a) < func(b)) ?
          b :
          a);
      }, coll[0]);
    }).call(this) :
    null);
}
////////////////////////////////////////////////////////////////////////////////
//fn: [take-while] in file: stdlib.ky, line: 2601
//Returns a sequence of successive items from coll while
//(pred item) returns logical true. pred must be free of side-effects.
function take_DASH_while(pred, coll) {
  let ret = list();
  for (let ____coll = coll, ____index = 0, ____end = count(____coll), ____break = false; ((!____break) && (____index < ____end)); ____index = (____index + 1)) {
    let c = ____coll[____index];
    if (pred(c)) {
      ret.push(c);
    } else {
      (
      ____break = true)
    }
  }
  return ret;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [drop-while] in file: stdlib.ky, line: 2613
//Returns a sequence of the items in coll starting from the
//first item for which (pred item) returns logical false.
function drop_DASH_while(pred, coll) {
  let ret = list();
  for (let ____coll = coll, i = 0, ____end = count(____coll), ____break = false; ((!____break) && (i < ____end)); i = (i + 1)) {
    let c = ____coll[i];
    if( (!pred(c)) ) {
      if (true) {
        for (let ____coll = coll, k = i, ____end = count(____coll), ____break = false; ((!____break) && (k < ____end)); k = (k + 1)) {
          let xx = ____coll[k];
          ret.push(xx);
        }
        (____break = true);
      }
    }
  }
  return ret;
}
////////////////////////////////////////////////////////////////////////////////
//fn: [split-with] in file: stdlib.ky, line: 2625
//Returns a vector of [(take-while pred coll) (drop-while pred coll)]
function split_DASH_with(pred, coll) {
  return vector(take_DASH_while(pred, coll), drop_DASH_while(pred, coll));
}
module.exports = {
  da57bc0172fb42438a11e6e8778f36fb: {
    ns: "czlab.kirby.stdlib",
    vars: ["MAX-INT", "MIN-INT", "DArray", "SPair", "Atom", "Keyword", "Symbol", "rtti", "rtti?", "println", "not-empty", "stringify", "opt??", "cons!", "conj!", "conj", "disj!", "disj", "pop!", "pop", "wrap-str", "getIndex", "getProp", "prn", "symbol?", "symbol", "keyword?", "keyword", "keyword->symbol", "atom?", "atom", "reset!", "objClass", "sort!", "deref", "swap!", "complex?", "simple?", "sequential?", "eq?", "object?", "last", "into", "map?", "set?", "list?", "list", "vector", "vector?", "object", "seq", "rseq", "contains?", "nichts?", "some?", "count", "hash-map", "hash-set", "concat*", "evens", "odds", "mod", "partition", "split", "split-str", "interleave", "zipmap", "zipobj", "extendAttr", "cons", "gensym", "assoc!", "dissoc!", "truthy?", "falsy?", "flatten", "identity", "monad-identity", "monad-maybe", "monad-list", "monad-state", "monad-continuation", "run-monad-continuation", "quote-str", "unquote-str", "esc-xml", "split-seq", "select-keys", "update-in!", "get-in", "merge", "mixin", "fill-array", "copy-array", "aclone", "difference", "percent", "to-fixed", "mapcat", "ensure-test", "ensure-test-thrown", "run-test", "push-nsp", "pop-nsp", "peek-nsp", "*ns*", "min-by", "max-by", "take-while", "drop-while", "split-with"],
    macros: {
      "this-as": "(macro* this-as (that & body) (syntax-quote (let [(unquote that) this] (splice-unquote body))))",
      "trye!": "(macro* trye! (& xs) (syntax-quote (try (splice-unquote xs) (catch ewroewrwe nil))))",
      "inc": "(macro* inc (x) (syntax-quote (+ 1 (unquote x))))",
      "dec": "(macro* dec (x) (syntax-quote (- (unquote x) 1)))",
      "empty?": "(macro* empty? (coll) (syntax-quote (== 0 (kirbyref/count (unquote coll)))))",
      "starts-with?": "(macro* starts-with? (s arg) (syntax-quote (.startsWith (unquote s) (unquote arg))))",
      "ends-with?": "(macro* ends-with? (s arg) (syntax-quote (.endsWith (unquote s) (unquote arg))))",
      "n#": "(macro* n# (coll) (syntax-quote (kirbyref/count (unquote coll))))",
      "_1": "(macro* _1 (x) (syntax-quote (first (unquote x))))",
      "_2": "(macro* _2 (x) (syntax-quote (second (unquote x))))",
      "_3": "(macro* _3 (x) (syntax-quote (nth (unquote x) 2)))",
      "trap!": "(macro* trap! (& msgs) (let* [sz (count* msgs)] (if* (> sz 1) (syntax-quote (throw (join \"\" (vector* (splice-unquote msgs))))) (if* (> sz 0) (syntax-quote (throw (unquote (nth* msgs 0)))) (syntax-quote (throw \"error!\"))))))",
      "raise!": "(macro* raise! (& msgs) (let* [sz (count* msgs)] (if* (> sz 1) (syntax-quote (throw (Error (join \"\" (vector* (splice-unquote msgs)))))) (if* (> sz 0) (syntax-quote (throw (Error (unquote (nth* msgs 0))))) (syntax-quote (throw (Error \"error!\")))))))",
      "slice": "(macro* slice (arr start end) (if* end (syntax-quote (Array.prototype.slice.call (unquote arr) (unquote start) (unquote end))) (if* start (syntax-quote (Array.prototype.slice.call (unquote arr) (unquote start))) (syntax-quote (Array.prototype.slice.call (unquote arr))))))",
      "numStr": "(macro* numStr (n) (syntax-quote (.toString (Number (unquote n)))))",
      "float": "(macro* float (x) (syntax-quote (parseFloat (unquote x))))",
      "int": "(macro* int (x) (syntax-quote (parseInt (unquote x))))",
      "delay": "(macro* delay (f t) (syntax-quote (setTimeout (unquote f) (unquote t))))",
      "break-out-of-loop!": "(macro* break-out-of-loop! () (syntax-quote (set! ____break true)))",
      "undef!": "(macro* undef! (x) (syntax-quote (set! (unquote x) undefined)))",
      "nil!": "(macro* nil! (x) (syntax-quote (set! (unquote x) nil)))",
      "last-index": "(macro* last-index (coll) (syntax-quote (- (alen (unquote coll)) 1)))",
      "rest": "(macro* rest (coll) (syntax-quote (.slice (unquote coll) 1)))",
      "cdr": "(macro* cdr (coll) (syntax-quote (.slice (unquote coll) 1)))",
      "second": "(macro* second (coll) (syntax-quote (nth (unquote coll) 1)))",
      "first": "(macro* first (coll) (syntax-quote (nth (unquote coll) 0)))",
      "car": "(macro* car (coll) (syntax-quote (nth (unquote coll) 0)))",
      "nexth": "(macro* nexth (coll i) (syntax-quote (nth (unquote coll) (inc (unquote i)))))",
      "nth": "(macro* nth (coll i) (syntax-quote (aget (unquote coll) (unquote i))))",
      "even?": "(macro* even? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (== 0 (kirbyref/mod (unquote x) 2)))) xs)))))",
      "odd?": "(macro* odd? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (!= 0 (kirbyref/mod (unquote x) 2)))) xs)))))",
      "alen": "(macro* alen (coll) (syntax-quote (.-length (unquote coll))))",
      "nzlen?": "(macro* nzlen? (coll) (syntax-quote (> (alen (unquote coll)) 0)))",
      "zlen?": "(macro* zlen? (coll) (syntax-quote (== (alen (unquote coll)) 0)))",
      "type": "(macro* type (obj) (syntax-quote (typeof (unquote obj))))",
      "whatis?": "(macro* whatis? (obj) (syntax-quote (Object.prototype.toString.call (unquote obj))))",
      "regex?": "(macro* regex? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (kirbyref/rtti? (unquote x) \"[object RegExp]\"))) xs)))))",
      "array?": "(macro* array? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (Array.isArray (unquote x)))) xs)))))",
      "date?": "(macro* date? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (kirbyref/rtti? (unquote x) \"[object Date]\"))) xs)))))",
      "XXmap?": "(macro* XXmap? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (kirbyref/rtti? (unquote x) \"[object Map]\"))) xs)))))",
      "XXset?": "(macro* XXset? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (kirbyref/rtti? (unquote x) \"[object Set]\"))) xs)))))",
      "bool?": "(macro* bool? (& xs) (syntax-quote (boolean? (splice-unquote xs))))",
      "boolean?": "(macro* boolean? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (== (typeof (unquote x)) \"boolean\"))) xs)))))",
      "num?": "(macro* num? (& xs) (syntax-quote (number? (splice-unquote xs))))",
      "number?": "(macro* number? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (== (typeof (unquote x)) \"number\"))) xs)))))",
      "str?": "(macro* str? (& xs) (syntax-quote (string? (splice-unquote xs))))",
      "string?": "(macro* string? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (== (typeof (unquote x)) \"string\"))) xs)))))",
      "fn?": "(macro* fn? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (== (typeof (unquote x)) \"function\"))) xs)))))",
      "undef?": "(macro* undef? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (== (typeof (unquote x)) \"undefined\"))) xs)))))",
      "def?": "(macro* def? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (!= (typeof (unquote x)) \"undefined\"))) xs)))))",
      "nil?": "(macro* nil? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (= (unquote x) nil))) xs)))))",
      "zero?": "(macro* zero? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (== (unquote x) 0))) xs)))))",
      "one?": "(macro* one? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (== (unquote x) 1))) xs)))))",
      "neg?": "(macro* neg? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (< (unquote x) 0))) xs)))))",
      "pos?": "(macro* pos? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (> (unquote x) 0))) xs)))))",
      "vals": "(macro* vals (obj) (syntax-quote (Array.from (.values (unquote obj)))))",
      "keys": "(macro* keys (obj) (syntax-quote (Array.from (.keys (unquote obj)))))",
      "properties": "(macro* properties (obj) (syntax-quote (Object.getOwnPropertyNames (unquote obj))))",
      "enumerables": "(macro* enumerables (obj) (syntax-quote (Object.keys (unquote obj))))",
      "assert": "(macro* assert (tst & msgs) (syntax-quote (if (unquote tst) true (raise! (splice-unquote msgs)))))",
      "false?": "(macro* false? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (= (unquote x) false))) xs)))))",
      "true?": "(macro* true? (& xs) (syntax-quote (_andp_* (splice-unquote (map* (lambda* [x] (syntax-quote (= (unquote x) true))) xs)))))",
      "when-not": "(macro* when-not (tst & xs) (syntax-quote (when (not (unquote tst)) (splice-unquote xs))))",
      "unless": "(macro* unless (tst & xs) (syntax-quote (when-not (unquote tst) (splice-unquote xs))))",
      "if-not": "(macro* if-not (tst then else) (syntax-quote (if (not (unquote tst)) (unquote then) (unquote else))))",
      "when": "(macro* when (tst & xs) (syntax-quote (if (unquote tst) (do (splice-unquote xs)))))",
      "cond": "(macro* cond (& xs) (let* [len (count* xs)] (do* (assert* (is-even? len) \"cond expects even args\") (if* (> len 0) (let* [c (nth* xs 0) e (nth* xs 1) r (rest* (rest* xs))] (if* (is-keyword? c) (syntax-quote (if true (unquote e))) (syntax-quote (if (unquote c) (unquote e) (cond (splice-unquote r))))))))))",
      "condp": "(macro* condp (pred expr & xs) (let* [Z (gensym*)] (syntax-quote (let [(unquote Z) (unquote expr)] (_kondp_ (unquote pred) (unquote Z) (splice-unquote xs))))))",
      "_kondp_": "(macro* _kondp_ (pred expr & xs) (let* [len (count* xs)] (if* (== len 1) (let* [e (nth* xs 0)] (syntax-quote (if true (unquote e)))) (if* (> len 1) (let* [c (nth* xs 0) e (nth* xs 1) e2 (nth* xs 2) r (rest* (rest* xs)) r2 (rest* (rest* (rest* xs)))] (if* (== e \">>\") (syntax-quote (if-let [____x ((unquote pred) (unquote c) (unquote expr))] ((unquote e2) ____x) (_kondp_ (unquote pred) (unquote expr) (splice-unquote r2)))) (syntax-quote (if ((unquote pred) (unquote c) (unquote expr)) (unquote e) (_kondp_ (unquote pred) (unquote expr) (splice-unquote r))))))))))",
      "->": "(macro* -> (expr form & xs) (let* [x (syntax-quote ((unquote (nth* form 0)) (unquote expr) (splice-unquote (rest* form))))] (if* (> (count* xs) 0) (syntax-quote (-> (unquote x) (splice-unquote xs))) (syntax-quote (unquote x)))))",
      "->>": "(macro* ->> (expr form & xs) (let* [x (syntax-quote ((splice-unquote form) (unquote expr)))] (if* (> (count* xs) 0) (syntax-quote (->> (unquote x) (splice-unquote xs))) (syntax-quote (unquote x)))))",
      "let": "(macro* let (bindings & xs) (let* [sz (count* xs)] (if* (> sz 0) (syntax-quote (with-local-vars [(splice-unquote bindings)] (splice-unquote xs))))))",
      "single?": "(macro* single? (coll) (syntax-quote (== 1 (kirbyref/count (unquote coll)))))",
      "double?": "(macro* double? (coll) (syntax-quote (== 2 (kirbyref/count (unquote coll)))))",
      "triple?": "(macro* triple? (coll) (syntax-quote (== 3 (kirbyref/count (unquote coll)))))",
      "loop": "(macro* loop (bindings & more) (let* [es (evens* bindings) os (odds* bindings)] (syntax-quote ((fn [] (with-local-vars [_x_ undefined recur undefined _f_ (fn [(splice-unquote es)] (splice-unquote more)) _r_ _f_]) (set! recur (fn [] (set! _x_ arguments) (raw# \"if (_r_) {for(_r_=undefined;_r_===undefined;){_r_=_f_.apply(this,_x_);} return _r_;}\") undefined)) (recur (splice-unquote os))) this))))",
      "concat": "(macro* concat (coll & xs) (syntax-quote (.concat (unquote coll) (splice-unquote xs))))",
      "join": "(macro* join (sep coll) (syntax-quote (.join (unquote coll) (unquote sep))))",
      "do-with": "(macro* do-with (bindings & xs) (let* [sz (count* bindings) _ (assert* (== sz 2) \"expected only 2 in form\") f (nth* bindings 0)] (syntax-quote (let [(unquote f) (unquote (nth* bindings 1))] (splice-unquote xs) (unquote f)))))",
      "do->false": "(macro* do->false (& xs) (syntax-quote (do (splice-unquote xs) false)))",
      "do->true": "(macro* do->true (& xs) (syntax-quote (do (splice-unquote xs) true)))",
      "do->this": "(macro* do->this (& xs) (syntax-quote (do (splice-unquote xs) this)))",
      "do->nil": "(macro* do->nil (& xs) (syntax-quote (do (splice-unquote xs) nil)))",
      "do->undef": "(macro* do->undef (& xs) (syntax-quote (do (splice-unquote xs) undefined)))",
      "do->break!": "(macro* do->break! (& xs) (syntax-quote (do (splice-unquote xs) (break-out-of-loop!))))",
      "dotimes": "(macro* dotimes (bindings & xs) (let* [sz (count* bindings) _ (assert* (== 2 sz) \"expected binary form\") b1 (first* bindings)] (syntax-quote (floop [:index (unquote b1) :end (unquote (nth* bindings 1))] (splice-unquote xs)))))",
      "range": "(macro* range (a b c) (let* [start (if* b a 0) end (if* b b a) step (if* c c 1)] (syntax-quote (do-with [ret (list*)] (floop [:start (unquote start) :end (unquote end) :step (unquote step) :index i] (.push ret i))))))",
      "apply": "(macro* apply (f this args) (syntax-quote (.apply (unquote f) (unquote this) (unquote args))))",
      "apply+": "(macro* apply+ (f this & args) (syntax-quote (.apply (unquote f) (unquote this) (vector* (splice-unquote args)))))",
      "ch@": "(macro* ch@ (s pos) (syntax-quote (.charAt (unquote s) (unquote pos))))",
      "false!": "(macro* false! (x) (syntax-quote (set! (unquote x) false)))",
      "true!": "(macro* true! (x) (syntax-quote (set! (unquote x) true)))",
      "repeat": "(macro* repeat (n x) (syntax-quote (do-with [ret (list*)] (floop [:end (unquote n)] (.push ret (unquote x))))))",
      "if-some+": "(macro* if-some+ (bindings then else) (let* [sz (count* bindings) _ (assert* (== 2 sz) \"expected binary form\") tst (gensym*)] (syntax-quote (let [(unquote tst) (unquote (nth* bindings 1)) (unquote (first* bindings)) (unquote tst)] (if (> (kirbyref/count (unquote tst)) 0) (unquote then) (unquote else))))))",
      "if-some": "(macro* if-some (bindings then else) (let* [sz (count* bindings) _ (assert* (== 2 sz) \"expected binary form\") tst (gensym*)] (syntax-quote (let [(unquote tst) (unquote (nth* bindings 1)) (unquote (first* bindings)) (unquote tst)] (if (or (undef? (unquote tst)) (nil? (unquote tst))) (unquote else) (unquote then))))))",
      "if-let": "(macro* if-let (bindings then else) (let* [sz (count* bindings) _ (assert* (== 2 sz) \"expected binary form\") tst (gensym*)] (syntax-quote (let [(unquote tst) (unquote (nth* bindings 1)) (unquote (first* bindings)) (unquote tst)] (if (unquote tst) (unquote then) (unquote else))))))",
      "when-some+": "(macro* when-some+ (bindings & xs) (let* [sz (count* bindings) _ (assert* (== 2 sz) \"expected binary form\") tst (gensym*)] (syntax-quote (let [(unquote tst) (unquote (nth* bindings 1)) (unquote (first* bindings)) (unquote tst)] (when (> (kirbyref/count (unquote tst)) 0) (splice-unquote xs))))))",
      "when-some": "(macro* when-some (bindings & xs) (let* [sz (count* bindings) _ (assert* (== 2 sz) \"expected binary form\") tst (gensym*)] (syntax-quote (let [(unquote tst) (unquote (nth* bindings 1)) (unquote (first* bindings)) (unquote tst)] (when-not (or (undef? (unquote tst)) (nil? (unquote tst))) (splice-unquote xs))))))",
      "when-let": "(macro* when-let (bindings & xs) (let* [sz (count* bindings) _ (assert* (== 2 sz) \"expected binary form\") tst (gensym*)] (syntax-quote (let [(unquote tst) (unquote (nth* bindings 1)) (unquote (first* bindings)) (unquote tst)] (when (unquote tst) (splice-unquote xs))))))",
      "doto": "(macro* doto (target & xs) (let* [v (gensym*)] (syntax-quote (let [(unquote v) (unquote target)] (splice-unquote (map* (lambda* [e] (syntax-quote ((unquote (first* e)) (unquote v) (splice-unquote (rest* e))))) xs)) (unquote v)))))",
      "map": "(macro* map (f coll) (syntax-quote (.map (or (unquote coll) (vector*)) (unquote f))))",
      "every": "(macro* every (f coll) (syntax-quote (.every (or (unquote coll) (vector*)) (unquote f))))",
      "find": "(macro* find (p coll) (syntax-quote (.find (or (unquote coll) (vector*)) (unquote p))))",
      "filter": "(macro* filter (p coll) (syntax-quote (.filter (or (unquote coll) (vector*)) (unquote p))))",
      "some": "(macro* some (p coll) (syntax-quote (.some (or (unquote coll) (vector*)) (unquote p))))",
      "take": "(macro* take (cnt coll) (syntax-quote (slice (unquote coll) 0 (unquote cnt))))",
      "constantly": "(macro* constantly (x) (syntax-quote (fn [& xs] (unquote x))))",
      "drop": "(macro* drop (cnt coll) (syntax-quote (slice (unquote coll) (unquote cnt))))",
      "reduce2": "(macro* reduce2 (f coll) (syntax-quote (.reduce (or (unquote coll) (vector*)) (unquote f))))",
      "reduce": "(macro* reduce (f start coll) (syntax-quote (.reduce (or (unquote coll) (vector*)) (unquote f) (unquote start))))",
      "foldl": "(macro* foldl (f start coll) (syntax-quote (reduce (unquote f) (unquote start) (unquote coll))))",
      "str": "(macro* str (& xs) (syntax-quote (.join (vector* (splice-unquote xs)) \"\")))",
      "lambda": "(macro* lambda (code) (let* [sz (count* code) body (if* (> sz 1) code (if* (> sz 0) (nth* code 0)))] (syntax-quote (fn [] (with-local-vars [____args (slice arguments)]) (unquote body)))))",
      "each": "(macro* each (func coll) (syntax-quote (.forEach (unquote coll) (unquote func))))",
      "each-property": "(macro* each-property (func obj) (let* [t (gensym*)] (syntax-quote (let [(unquote t) (unquote obj)] (each (fn [p] ((unquote func) (get (unquote t) p) p)) (properties (unquote t)))))))",
      "each-enumerable": "(macro* each-enumerable (func obj) (let* [t (gensym*)] (syntax-quote (let [(unquote t) (unquote obj)] (each (fn [p] ((unquote func) (get (unquote t) p) p)) (enumerables (unquote t)))))))",
      "each-key": "(macro* each-key (func obj) (let* [t (gensym*) f (gensym*)] (syntax-quote (let [(unquote t) (unquote obj) (unquote f) (unquote func)] (if (kirbyref/object? (unquote t)) (each-enumerable (unquote f) (unquote t)) (each (unquote f) (unquote t)))))))",
      "dosync": "(macro* dosync (& exprs) (syntax-quote (do (splice-unquote exprs))))",
      "monad": "(macro* monad (docstring operations) (syntax-quote (with-local-vars [bind nil unit nil zero nil plus nil] (let [(splice-unquote operations)] (object* :bind bind :unit unit :zero zero :plus plus)))))",
      "defmonad": "(macro* defmonad (name docs operations) (let* [ds (if* (is-str? docs) docs \"\") ps (if* (is-str? docs) operations (if* (is-array? docs) docs)) _ (assert* (is-array? ps) \"no macro operations\")] (syntax-quote (const (unquote name) (monad (unquote ds) (unquote ps))))))",
      "dobind": "(macro* dobind (mbind steps expr) (let* [mv (nth* steps 1) a1 (nth* steps 0) more (rest* (rest* steps))] (syntax-quote ((unquote mbind) (unquote mv) (fn [(unquote a1)] (unquote (if* (not-empty* more) (syntax-quote (dobind (unquote mbind) (unquote more) (unquote expr))) (syntax-quote (do (unquote expr))))))))))",
      "domonad": "(macro* domonad (monad steps body) (syntax-quote ((fn [mo] (with-local-vars [bind (.-bind mo) unit (.-unit mo) zero (.-zero mo) ret (lambda (if (and (kirbyref/nichts? %1) (kirbyref/some? zero)) zero (unit %1)))]) (dobind bind (unquote steps) (ret (unquote body)))) (unquote monad))))",
      "deftest": "(macro* deftest (name & body) (syntax-quote (const (unquote name) (lambda (vector* (splice-unquote body))))))",
      "ensure": "(macro* ensure (form msg) (syntax-quote (kirbyref/ensure-test (unquote form) (unquote msg))))",
      "ensure-thrown": "(macro* ensure-thrown (expected form msg) (syntax-quote (try (unquote form) (kirbyref/ensure-test-thrown (unquote expected) nil (unquote msg)) (catch e (kirbyref/ensure-test-thrown (unquote expected) e (unquote msg))))))",
      "assert*": "(macro* assert* (c msg) (syntax-quote (if* (unquote c) true (throw* (unquote msg)))))",
      "cond*": "(macro* cond* (& xs) (if* (> (count* xs) 0) (list* (quote if*) (first* xs) (nth* xs 1) (cons* (quote cond*) (rest* (rest* xs))))))",
      "_andp_*": "(macro* _andp_* (& xs) (if* (= 1 (unquote (count* xs))) (syntax-quote (unquote (first* xs))) (syntax-quote (and (splice-unquote xs)))))",
      "with-local-vars": "(macro* with-local-vars (bindings & more) (let* [_ (assert* (is-array? bindings) \"expecting array as bindings\") e (count* more) b (count* bindings)] (if* (not* (is-even? b)) (throw* \"wanted even number of binding forms\") (if* (> e 0) (syntax-quote (do (vars (splice-unquote bindings)) (splice-unquote more))) (syntax-quote (vars (splice-unquote bindings)))))))",
      "binding": "(macro* binding (bindings & xs) (syntax-quote ((fn [] (set! (splice-unquote bindings)) (splice-unquote xs)))))"
    }
  },
  MAX_DASH_INT: MAX_DASH_INT,
  MIN_DASH_INT: MIN_DASH_INT,
  DArray: DArray,
  SPair: SPair,
  Atom: Atom,
  Keyword: Keyword,
  Symbol: Symbol,
  rtti: rtti,
  rtti_QMRK: rtti_QMRK,
  println: println,
  not_DASH_empty: not_DASH_empty,
  stringify: stringify,
  opt_QMRK__QMRK: opt_QMRK__QMRK,
  cons_BANG: cons_BANG,
  conj_BANG: conj_BANG,
  conj: conj,
  disj_BANG: disj_BANG,
  disj: disj,
  pop_BANG: pop_BANG,
  pop: pop,
  wrap_DASH_str: wrap_DASH_str,
  getIndex: getIndex,
  getProp: getProp,
  prn: prn,
  symbol_QMRK: symbol_QMRK,
  symbol: symbol,
  keyword_QMRK: keyword_QMRK,
  keyword: keyword,
  keyword_DASH__GT_symbol: keyword_DASH__GT_symbol,
  atom_QMRK: atom_QMRK,
  atom: atom,
  reset_BANG: reset_BANG,
  objClass: objClass,
  sort_BANG: sort_BANG,
  deref: deref,
  swap_BANG: swap_BANG,
  complex_QMRK: complex_QMRK,
  simple_QMRK: simple_QMRK,
  sequential_QMRK: sequential_QMRK,
  eq_QMRK: eq_QMRK,
  object_QMRK: object_QMRK,
  last: last,
  into: into,
  map_QMRK: map_QMRK,
  set_QMRK: set_QMRK,
  list_QMRK: list_QMRK,
  list: list,
  vector: vector,
  vector_QMRK: vector_QMRK,
  object: object,
  seq: seq,
  rseq: rseq,
  contains_QMRK: contains_QMRK,
  nichts_QMRK: nichts_QMRK,
  some_QMRK: some_QMRK,
  count: count,
  hash_DASH_map: hash_DASH_map,
  hash_DASH_set: hash_DASH_set,
  concat_STAR: concat_STAR,
  evens: evens,
  odds: odds,
  mod: mod,
  partition: partition,
  split: split,
  split_DASH_str: split_DASH_str,
  interleave: interleave,
  zipmap: zipmap,
  zipobj: zipobj,
  extendAttr: extendAttr,
  cons: cons,
  gensym: gensym,
  assoc_BANG: assoc_BANG,
  dissoc_BANG: dissoc_BANG,
  truthy_QMRK: truthy_QMRK,
  falsy_QMRK: falsy_QMRK,
  flatten: flatten,
  identity: identity,
  monad_DASH_identity: monad_DASH_identity,
  monad_DASH_maybe: monad_DASH_maybe,
  monad_DASH_list: monad_DASH_list,
  monad_DASH_state: monad_DASH_state,
  monad_DASH_continuation: monad_DASH_continuation,
  run_DASH_monad_DASH_continuation: run_DASH_monad_DASH_continuation,
  quote_DASH_str: quote_DASH_str,
  unquote_DASH_str: unquote_DASH_str,
  esc_DASH_xml: esc_DASH_xml,
  split_DASH_seq: split_DASH_seq,
  select_DASH_keys: select_DASH_keys,
  update_DASH_in_BANG: update_DASH_in_BANG,
  get_DASH_in: get_DASH_in,
  merge: merge,
  mixin: mixin,
  fill_DASH_array: fill_DASH_array,
  copy_DASH_array: copy_DASH_array,
  aclone: aclone,
  difference: difference,
  percent: percent,
  to_DASH_fixed: to_DASH_fixed,
  mapcat: mapcat,
  ensure_DASH_test: ensure_DASH_test,
  ensure_DASH_test_DASH_thrown: ensure_DASH_test_DASH_thrown,
  run_DASH_test: run_DASH_test,
  push_DASH_nsp: push_DASH_nsp,
  pop_DASH_nsp: pop_DASH_nsp,
  peek_DASH_nsp: peek_DASH_nsp,
  _STAR_ns_STAR: _STAR_ns_STAR,
  min_DASH_by: min_DASH_by,
  max_DASH_by: max_DASH_by,
  take_DASH_while: take_DASH_while,
  drop_DASH_while: drop_DASH_while,
  split_DASH_with: split_DASH_with
};