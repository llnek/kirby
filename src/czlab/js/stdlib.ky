;; Licensed under the Apache License, Version 2.0 (the "License");
;; you may not use this file except in compliance with the License.
;; You may obtain a copy of the License at
;;     http://www.apache.org/licenses/LICENSE-2.0
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.
;; Copyright Â© 2013-2022, Kenneth Leung. All rights reserved. */

(ns
  ^{:author "Kenneth Leung"}
  czlab.kirby.stdlib
  "Standard core library containing built-in functions/vars and macros."

  (:require ["./core" :as core]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(const MAX-INT Number/MAX_SAFE_INTEGER)
(const MIN-INT Number/MIN_SAFE_INTEGER)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro this-as

  """Defines a scope where JavaScript's implicit `this` is bound to the name provided"""
  [that & body]

  `(let [~that this] ~@body))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;not used, done via reader
(defmacro XXXlambda

  """Defines a function, with anonymous args"""
  [code]

  (let* [sz (count* code)
         body (if* (> sz 1)
                   code
                   (if* (> sz 0) (nth* code 0)))]
    `(fn [] (with-local-vars [____args (slice arguments)]) ~body)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro trye!

  """Wrap try block around code and eat exception"""
  [&xs]

  `(try ~@xs (catch ewroewrwe nil)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro inc

  """Returns a number one greater than x"""
  [x]

  `(+ 1 ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro dec

  """Returns a number one lesser than x"""
  [x]

  `(- ~x 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro empty?

  """Returns true if coll has no items"""
  [coll]

  `(== 0 (kirbyref/count ~coll)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro starts-with?

  """Determines whether a string begins with the characters
    of a specified string, returning true or false as appropriate."""
  [s arg]

  `(.startsWith ~s ~arg))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ends-with?

  """Determines whether a string ends with the characters
    of a specified string, returning true or false as appropriate."""
  [s arg]

  `(.endsWith ~s ~arg))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro n#

  """Refer to count."""
  [coll]

  `(kirbyref/count ~coll))

 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro _1

  """Refer to first"""
  [x]

  `(first ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro _2

  """Refer to second"""
  [x]

  `(second ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro _3

  """Returns the third item in the collection"""
  [x]

  `(nth ~x 2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro trap!

  """Throw a string"""
  [&msgs]

  (let* [sz (count* msgs)]
    (if* (> sz 1)
      `(throw (join "" (vec ~@msgs)))
      (if* (> sz 0)
        `(throw ~(nth* msgs 0)) `(throw "error!")))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro raise!

  """Throw an Error Object"""
  [&msgs]

  (let* [sz (count* msgs)]
    (if* (> sz 1)
      `(throw (Error (join "" (vec ~@msgs))))
      (if* (> sz 0)
        `(throw (Error ~(nth* msgs 0))) `(throw (Error "error!"))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro slice

  """Returns a shallow copy of a portion of an array
    into a new array object selected from begin to end (end not included)"""
  [arr &[start end]]

  (if* end
       `(Array.prototype.slice.call ~arr ~start ~end)
       (if* start
            `(Array.prototype.slice.call ~arr ~start)
            `(Array.prototype.slice.call ~arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro numStr

  """A number into string"""
  [n]

  `(.toString (Number ~n)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro float

  """A string into float"""
  [x]

  `(parseFloat ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro int

  """A string into int"""
  [x]

  `(parseInt ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro delay

  """Run function at a later time"""
  [f t]

  `(setTimeout ~f ~t))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro break-out-of-loop!

  """Toggle *break*"""
  []

  `(set! ____break true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro undef!

  """Set x to undefined"""
  [x]

  `(set! ~x undefined))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nil!

  """Set x to null"""
  [x]

  `(set! ~x nil))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro last-index

  """Length -1"""
  [coll]

  `(- (alen ~coll) 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro rest

  """Returns a possibly empty seq of the items after the first"""
  [coll]

  `(.slice ~coll 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro cdr

  """Refer to rest"""
  [coll]

  `(.slice ~coll 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro second

  """Get the second item"""
  [coll]

  `(nth ~coll 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro first

  """Get the first item"""
  [coll]

  `(nth ~coll 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro car

  """Refer to first"""
  [coll]

  `(nth ~coll 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nexth

  """Get the next item after i"""
  [coll i]

  `(nth ~coll (inc ~i)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nth

  """Get the item at index i"""

  [coll i]

  `(aget ~coll ~i))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro even?

  """True if all args are even"""
  [&xs]

  (let* [arr (map* (lambda* [x] `(== 0 (kirbyref/mod ~x 2))) xs)]
    (if* (= 1 (count* arr)) `~(first* arr) `(and ~@arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro odd?

  """True if all args are odd"""
  [&xs]

  (let* [arr (map* (lambda* [x] `(!= 0 (kirbyref/mod ~x 2))) xs)]
    (if* (= 1 (count* arr)) `~(first* arr) `(and ~@arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro alen

  """Length of array"""
  [coll]

  `(.-length ~coll))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nzlen?

  """Array length > 0"""
  [coll]

  `(> (alen ~coll) 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro zlen?

  """Array length is 0"""
  [coll]

  `(== (alen ~coll) 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro type

  """Type of object"""
  [obj]

  `(typeof ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro whatis?

  """Long form of object type"""
  [obj]

  `(Object.prototype.toString.call ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro regex?

  """True if all args are RegExps"""
  [&xs]

  (let* [arr (map* (lambda* [x] `(kirbyref/rtti? ~x "[object RegExp]")) xs)]
    (if* (= 1 (count* arr)) `~(first* arr) `(and ~@arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro array?

  """True if all args are arrays"""
  [&xs]

  (let* [arr (map* (lambda* [x] `(Array.isArray ~x)) xs)]
    (if* (= 1 (count* arr)) `~(first* arr) `(and ~@arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro date?

  """True if all args are Dates"""
  [&xs]

  (let* [arr (map* (lambda* [x] `(kirbyref/rtti? ~x "[object Date]")) xs)]
    (if* (= 1 (count* arr)) `~(first* arr) `(and ~@arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro bool?

  """Refer to boolean?"""
  [&xs]

  `(boolean? ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro boolean?

  """True if all args are booleans"""
  [&xs]

  (let* [arr (map* (lambda* [x] `(== (typeof ~x) "boolean")) xs)]
    (if* (= 1 (count* arr)) `~(first* arr) `(and ~@arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro num?

  """Refer to number?"""
  [&xs]

  `(number? ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro number?

  """True if all args are numbers"""
  [&xs]

  (let* [arr (map* (lambda* [x] `(== (typeof ~x) "number")) xs)]
    (if* (= 1 (count* arr)) `~(first* arr) `(and ~@arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro str?

  """Refer to string?"""
  [&xs]

  `(string? ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro string?

  """True if all args are strings"""
  [&xs]

  (let* [arr (map* (lambda* [x] `(== (typeof ~x) "string")) xs)]
    (if* (= 1 (count* arr)) `~(first* arr) `(and ~@arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro fn?

  """True if all args are functions"""
  [&xs]

  (let* [arr (map* (lambda* [x] `(== (typeof ~x) "function")) xs)]
    (if* (= 1 (count* arr)) `~(first* arr) `(and ~@arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro undef?

  """True if all args are undefineds"""
  [&xs]

  (let* [arr (map* (lambda* [x] `(== (typeof ~x) "undefined")) xs)]
    (if* (= 1 (count* arr)) `~(first* arr) `(and ~@arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro def?

  """True if all args are defined"""
  [&xs]

  (let* [arr (map* (lambda* [x] `(!= (typeof ~x) "undefined")) xs)]
    (if* (= 1 (count* arr)) `~(first* arr) `(and ~@arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro nil?

  """True if all args are nulls"""
  [&xs]

  (let* [arr (map* (lambda* [x] `(= ~x null)) xs)]
    (if* (= 1 (count* arr)) `~(first* arr) `(and ~@arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro zero?

  """True if all args are zeros"""
  [&xs]

  (let* [arr (map* (lambda* [x] `(== ~x 0)) xs)]
    (if* (= 1 (count* arr)) `~(first* arr) `(and ~@arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro one?

  """True if all args are 1s"""
  [&xs]

  (let* [arr (map* (lambda* [x] `(== ~x 1)) xs)]
    (if* (= 1 (count* arr)) `~(first* arr) `(and ~@arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro neg?

  """True if all args are negative"""
  [&xs]

  (let* [arr (map* (lambda* [x] `(< ~x 0)) xs)]
    (if* (= 1 (count* arr)) `~(first* arr) `(and ~@arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro pos?

  """True if all args are positive"""
  [&xs]

  (let* [arr (map* (lambda* [x] `(> ~x 0)) xs)]
    (if* (= 1 (count* arr)) `~(first* arr) `(and ~@arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro vals

  """The values for each element in the Map or Set object"""
  [obj]

  `(Array.from (.values ~obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro keys

  """The keys for each element in the Map object"""
  [obj]

  `(Array.from (.keys ~obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro properties

  """Returns all properties (including non-enumerable properties
    except for those which use Symbol) found directly upon a given object"""
  [obj]

  `(Object.getOwnPropertyNames ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro enumerables

  """Returns a given object's own enumerable properties"""
  [obj]

  `(Object.keys ~obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro assert

  """Assert a condition else throw Error"""
  [tst & msgs]

  `(if ~tst true (raise! ~@msgs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro false?

  """True if all args are false"""
  [&xs]

  (let* [arr (map* (lambda* [x] `(= ~x false)) xs)]
    (if* (= 1 (count* arr)) `~(first* arr) `(and ~@arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro true?

  """True if all args are true"""
  [&xs]

  (let* [arr (map* (lambda* [x] `(= ~x true)) xs)]
    (if* (= 1 (count* arr)) `~(first* arr) `(and ~@arr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when-not

  """Evaluates test. If logical false, evaluates body in an implicit do"""
  [tst & xs]

  `(when (not ~tst) ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro unless

  """Refer to when-not"""
  [tst & xs]

  `(when-not ~tst ~@xs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro if-not

  """Evaluates test. If logical false, evaluates and
    returns then expr, otherwise else expr, if supplied, else nil"""
  [tst then & [else]]

  `(if (not ~tst) ~then ~else))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when

  """Evaluates test. If logical true, evaluates body in an implicit do"""
  [tst & xs]

  `(if ~tst (do ~@xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro cond

  """Takes a set of test/expr pairs. It evaluates each test one at a time.
    If a test returns logical true, cond evaluates and returns
    the value of the corresponding expr and doesn't evaluate any of the
    other tests or exprs."""
  [&xs]

  (let* [len (count* xs)]
    (do* (assert* (is-even? len)
                  "cond expects even args")
         (if* (> len 0)
           (let* [c (nth* xs 0)
                  e (nth* xs 1)
                  r (rest* (rest* xs))]
             (if* (is-keyword? c)
               `(if true ~e)
               `(if ~c ~e (cond ~@r))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro condp

  """Takes a binary predicate, an expression, and a set of clauses.
    Each clause can take the form of either:
    test-expr result-expr
    test-expr :>> result-fn
    Note :>> is an ordinary keyword.
    For each clause, (pred test-expr expr) is evaluated. If it returns
    logical true, the clause is a match. If a binary clause matches, the
    result-expr is returned, if a ternary clause matches, its result-fn,
    which must be a unary function, is called with the result of the
    predicate as its argument, the result of that call being the return
    value of condp. A single default expression can follow the clauses,
    and its value will be returned if no clause matches. If no default
    expression is provided and no clause matches, returns nil"""
  [pred expr & xs]

  (let* [Z (gensym*)]
    `(let [~Z ~expr]
       (_kondp_ ~pred ~Z ~@xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro _kondp_

  """internal for complex condp"""
  [pred expr & xs]

  (let* [len (count* xs)]
    (if* (== len 1)
         (let* [e (nth* xs 0)] `(if true ~e))
         (if* (> len 1)
              (let* [c (nth* xs 0)
                     e (nth* xs 1)
                     e2 (nth* xs 2)
                     r (rest* (rest* xs))
                     r2 (rest* (rest* (rest* xs)))]
                (if* (==  e ">>")
                     `(if-let [____x (~pred ~c ~expr)]
                        (~e2 ____x)
                        (_kondp_ ~pred ~expr ~@r2))
                     `(if (~pred ~c ~expr) ~e (_kondp_ ~pred ~expr ~@r))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ->

  """Threads the expr through the forms. Inserts x as the
    second item in the first form, making a list of it if it is not a
    list already. If there are more forms, inserts the first form as the
    second item in second form, etc"""
  [expr form & xs]

  (let* [x `(~(nth* form 0)
                    ~expr ~@(rest* form))]
    (if* (> (count* xs) 0) `(-> ~x ~@xs) `~x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ->>

  """Threads the expr through the forms. Inserts x as the
    last item in the first form, making a list of it if it is not a
    list already. If there are more forms, inserts the first form as the
    last item in second form, etc."""
  [expr form & xs]

  (let* [x `(~@form ~expr)]
    (if* (> (count* xs) 0) `(->> ~x ~@xs) `~x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro let

  """binding => binding-form init-expr
    Evaluates the exprs in a lexical context in which the symbols in
    the binding-forms are bound to their respective init-exprs or parts
    therein"""
  [bindings & xs]

  (let* [sz (count* xs)]
    (if* (> sz 0)
         `(with-local-vars [~@bindings] ~@xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro single?

  """True if coll has only 1 item"""
  [coll]

  `(== 1 (kirbyref/count ~coll)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro double?

  """True if coll has only 2 items"""
  [coll]

  `(== 2 (kirbyref/count ~coll)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro triple?

  """True if coll has only 3 items"""
  [coll]

  `(== 3 (kirbyref/count ~coll)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;uses the trampoline technique
(defmacro loop

  """Evaluates the exprs in a lexical context in which the symbols in
    the binding-forms are bound to their respective init-exprs or parts
    therein. Acts as a recur target"""
  [bindings & more]

  (let* [es (evens* bindings)
         os (odds* bindings)]
    `((fn []
        (with-local-vars
          [_x_ nil
           recur nil
           _zz_ (new Object)
           _f_ (fn [~@es] ~@more) _r_ _f_])
        (set! recur
              (fn []
                (set! _x_ (Array.prototype.slice.call arguments 0))
                (raw# "if(_r_ !== _zz_){_r_=_zz_;while(_r_===_zz_){_r_=_f_.apply(this,_x_)} return _r_}")
                _zz_))
        (recur ~@os)) this)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro join

  """Returns a string of all elements in coll, as returned by (seq coll),
    separated by a separator"""
  [sep coll]

  `(.join ~coll ~sep))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do-with

  """varbinding=> symbol init-expr
    Executes the body in a context in which the symbol is always the
    returned value"""
  [bindings & xs]

  (let* [sz (count* bindings)
         _ (assert* (== sz 2)
                    "expected only 2 in form")
         f (nth* bindings 0)]
    `(let [~f ~(nth* bindings 1)] ~@xs ~f)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->false

  """Executes the exprs in a context in which false is always the returned value"""
  [&xs]

  `(do ~@xs false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->true

  """Executes the exprs in a context in which true is always the returned value"""
  [&xs]

  `(do ~@xs true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->this

  """Executes the exprs in a context in which 'this' is always the returned value"""
  [&xs]

  `(do ~@xs this))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->nil

  """Executes the exprs in a context in which null is always the returned value"""
  [&xs]

  `(do ~@xs nil))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->undef

  """Executes the exprs in a context in which undefined is always the returned value"""
  [&xs]

  `(do ~@xs undefined))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro do->break!

  """Executes the exprs in a context and ends with a toggle on *break*"""
  [&xs]

  `(do ~@xs (break-out-of-loop!)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro dotimes

  """bindings => name n
    Repeatedly executes body (presumably for side-effects) with name
    bound to integers from 0 through n-1"""
  [bindings &xs]

  (let* [sz (count* bindings)
         _ (assert* (== 2 sz)
                    "expected binary form")
         b1 (first* bindings)]
    `(floop [:index ~b1 :end ~(nth* bindings 1)] ~@xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro range

  """(range end)(range start end)(range start end step)
    Returns a seq of nums from start (inclusive) to end
    (exclusive), by step, where start defaults to 0, step to 1"""
  [a & [b c]]

  (let* [start (if* b a 0)
         end (if* b b a)
         step (if* c c 1)]
    `(do-with [ret (list)]
       (floop [:start ~start :end ~end :step ~step :index i] (.push ret i)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro apply

  """Applies fn f to the  args"""
  [f this args]

  `(.apply ~f ~this ~args))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro apply+

  """Applies fn f to the var-args"""
  [f this & args]

  `(.apply ~f ~this (vec ~@args)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ch@

  """Returns a new string consisting of the single UTF-16 code unit
    located at the specified offset into the string"""
  [s pos]

  `(.charAt ~s ~pos))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro false!

  """Set x to false"""
  [x]

  `(set! ~x false))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro true!

  """Set x to true"""
  [x]

  `(set! ~x true))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro repeat

  """Returns a sequence of n x's"""
  [n x]

  `(do-with [ret (list)]
     (floop [:end ~n] (.push ret ~x))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro if-some+

  """bindings => binding-form test
    If test is not empty, evaluates then with binding-form bound to the
    value of test, if not, yields else"""
  [bindings then & [else]]

  (let* [sz (count* bindings)
         _ (assert* (== 2 sz)
                    "expected binary form")
         tst (gensym*)]
    `(let [~tst ~(nth* bindings 1)
           ~(first* bindings) ~tst]
       (if (> (kirbyref/count ~tst) 0) ~then ~else))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro if-some

  """bindings => binding-form test
    If test is not undefined/nil, evaluates then with binding-form bound to the
    value of test, if not, yields else"""
  [bindings then & [else]]

  (let* [sz (count* bindings)
         _ (assert* (== 2 sz)
                    "expected binary form")
         tst (gensym*)]
    `(let [~tst ~(nth* bindings 1)
           ~(first* bindings) ~tst]
       (if (or (undef? ~tst)
               (nil? ~tst)) ~else ~then))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro if-let

  """bindings => binding-form test
    If test is true, evaluates then with binding-form bound to the value of
    test, if not, yields else"""
  [bindings then & [else]]

  (let* [sz (count* bindings)
         _ (assert* (== 2 sz)
                    "expected binary form")
         tst (gensym*)]
    `(let [~tst ~(nth* bindings 1)
           ~(first* bindings) ~tst] (if ~tst ~then ~else))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when-some+

  """bindings => binding-form test
    When test is not empty, evaluates body with binding-form bound to the
    value of test"""
  [bindings &xs]

  (let* [sz (count* bindings)
         _ (assert* (== 2 sz)
                    "expected binary form")
         tst (gensym*)]
    `(let [~tst ~(nth* bindings 1)
           ~(first* bindings) ~tst]
       (when (> (kirbyref/count ~tst) 0) ~@xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when-some

  """bindings => binding-form test
    When test is not undefined/nil, evaluates body with binding-form bound to the
    value of test"""
  [bindings &xs]

  (let* [sz (count* bindings)
         _ (assert* (== 2 sz)
                    "expected binary form")
         tst (gensym*)]
    `(let [~tst ~(nth* bindings 1)
           ~(first* bindings) ~tst]
       (when-not (or (undef? ~tst)
                     (nil? ~tst)) ~@xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro when-let

  """bindings => binding-form test
    When test is true, evaluates body with binding-form bound to the value of test"""
  [bindings &xs]

  (let* [sz (count* bindings)
         _ (assert* (== 2 sz)
                    "expected binary form")
         tst (gensym*)]
    `(let [~tst ~(nth* bindings 1)
           ~(first* bindings) ~tst] (when ~tst ~@xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro doto

  """Evaluates x then calls all of the methods and functions with the
    value of x supplied at the front of the given arguments.  The forms
    are evaluated in order.  Returns x.
    (doto (new Map) (.set \"a\" 1) (.set \"b\" 2))"""
  [target & xs]

  (let* [v (gensym*)]
    `(let [~v ~target]
       ~@(map* (lambda* [e]
                    `(~(first* e) ~v ~@(rest* e))) xs) ~v)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro map

  """Creates a new array with the results of
    calling a provided function on every element in the calling array"""
  [f coll]

  `(.map (or ~coll (vec)) ~f))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro every

  """Tests whether all elements in the array pass the test
    implemented by the provided function"""
  [f coll]

  `(.every (or ~coll (vec)) ~f))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro find

  """Returns the value of the first element in the array
    that satisfies the predicate. Otherwise undefined is returned"""
  [p coll]

  `(.find  (or ~coll (vec)) ~p))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro filter

  """Creates a new array with all elements that
    pass the test implemented by the provided predicate"""
  [p coll]

  `(.filter (or ~coll (vec)) ~p))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro some

  """Tests whether at least one element in the array
    passes the test implemented by the provided predicate"""
  [p coll]

  `(.some (or ~coll (vec)) ~p))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro take

  """Returns a sequence of the first n items in coll,
    or all items if there are fewer than n"""
  [cnt coll]

  `(slice ~coll 0 ~cnt))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro constantly

  """Returns a function that takes any number of arguments and returns x"""
  [x]

  `(fn [&xs] ~x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro drop

  """Returns a sequence of all but the first n items in coll"""
  [cnt coll]

  `(slice ~coll ~cnt))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro reduce2

  """Applies a function against an accumulator and
    each element in the array (from left to right)
    to reduce it to a single value. No initial value"""
  [f coll]

  `(.reduce (or ~coll (vec)) ~f))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro reduce

  """Applies a function against an accumulator and
    each element in the array (from left to right)
    to reduce it to a single value"""
  [f start coll]

  `(.reduce (or ~coll (vec)) ~f ~start))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro foldl

  """Refer to reduce"""
  [f start coll]

  `(reduce ~f ~start ~coll))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro str

  """With no args, returns the empty string. With one arg x, returns
    x.toString().  (str nil) returns the empty string. With more than
    one arg, returns the concatenation of the str values of the args"""
  [&xs]

  `(.join (vec ~@xs) ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro each

  """Executes a provided function once for each array element"""
  [func coll]

  `(.forEach ~coll ~func))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro each-property

  """Refer to each - iterates through keys of an obj"""
  [func obj]

  (let* [t (gensym*)]
    `(let [~t ~obj]
       (each (fn [p] (~func (get ~t p) p)) (properties ~t)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro each-enumerable

  """Refer to each - iterates through enumerable keys of an obj"""
  [func obj]

  (let* [t (gensym*)]
    `(let [~t ~obj]
       (each (fn [p] (~func (get ~t p) p)) (enumerables ~t)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro each-key

  """Refer to each - iterates through a Map or Object"""
  [func obj]

  (let* [t (gensym*)
         f (gensym*)]
    `(let [~t ~obj
           ~f ~func]
       (if (kirbyref/object? ~t)
         (each-enumerable ~f ~t) (each ~f ~t)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro dosync

  """For now, like do"""
  [&exprs]

  `(do ~@exprs))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;monads
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro monad

  "Define a monad by defining the monad operations. The definitions
   are written like bindings to the monad operations bind and
   unit (required) and zero and plus (optional)."

  ^:internal [docstring operations]

  `(with-local-vars [bind nil unit nil zero nil plus nil]
     (let [~@operations]
       (js-obj :bind bind :unit unit :zero zero :plus plus))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro defmonad

  "Define a named monad by defining the monad operations. The definitions
   are written like bindings to the monad operations bind and
   unit (required) and zero and plus (optional)."

  [name & [docs operations]]
  (let* [ds (if* (is-str? docs) docs "")
         ps (if* (is-str? docs)
                 operations
                 (if* (is-sequential? docs) docs))
         _ (assert* (is-sequential? ps)
                    "no macro operations")]
    `(const ~name (monad ~ds ~ps))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro dobind
  ""
  ^:internal [mbind steps expr]
  (let* [mv (nth* steps 1)
         a1 (nth* steps 0)
         more (rest* (rest* steps))]
    `(~mbind ~mv
             (fn [~a1]
               ~(if* (not-empty* more)
                     `(dobind ~mbind ~more ~expr)
                     `(do ~expr))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro domonad

  "Monad comprehension. Takes the name of a monad, a vector of steps
   given as binding-form, and a result value
   specified by body."

  [monad steps body]
  `((fn [mo]
      (with-local-vars
        [bind (.-bind mo)
         unit (.-unit mo)
         zero (.-zero mo)
         ret #(if (and (kirbyref/nichts? %)
                       (kirbyref/some? zero)) zero (unit %))])
      (dobind bind ~steps (ret ~body))) ~monad))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;testing stuff
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro deftest
  "" [name & body] `(const ~name #(vec ~@body)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ensure
  "" [form msg] `(kirbyref/ensure-test ~form ~msg))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro ensure-thrown
  "" [expected form msg]
  `(try ~form
        (kirbyref/ensure-test-thrown ~expected nil ~msg)
        (catch e
          (kirbyref/ensure-test-thrown ~expected e ~msg))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro assert*
  "" [c msg] `(if* ~c true (throw* ~msg)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro cond*
  "" [&xs]
  (if* (> (count* xs) 0)
    (list* 'if*
          (first* xs)
          (nth* xs 1)
          (cons* 'cond* (rest* (rest* xs))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro with-local-vars "" [bindings & more]
  (let* [_ (assert* (is-sequential? bindings)
                    "expecting array as bindings")
         e (count* more)
         b (count* bindings)]
    (if* (not* (is-even? b))
       (throw* "wanted even number of binding forms")
       (if* (> e 0)
         `(do (vars ~@bindings) ~@more)
         `(vars ~@bindings )))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmacro binding
  "" [bindings & xs]
  `((fn [] (set! ~@bindings) ~@xs)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;END MACROS

(def Keyword core/Keyword)
(def DArray core/DArray)
(def SPair core/SPair)
(def Atom core/Atom)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn rtti

  """Runtime type info of this object."""
  [obj]

  (whatis? obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn rtti?

  "Check the runtime type info of this object."
  [obj, t]

  (== (whatis? obj) t))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn println

  "Write msg to console."
  [&msgs]

  (if console (console.log (join "" msgs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn not-empty

  "Check if coll is empty, returns nil, else coll."
  [coll]

  (if (empty? coll) nil coll))

//////////////////////////////////////////////////////////////////////////////
(defn- is-simple?

  "Check if input is a primitive type."
  [x]

  (or (== (typeof x) "boolean")
      (== (typeof x) "string")
      (== (typeof x) "number")
      (= x nil)
      (= x undefined)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- no-cref

  "Use a cache to store already referenced objects
  to prevent circular references."
  []

  (with-local-vars [cache []])
  (fn [k v]
    (if (fn? v)
      (set! v (or (.-name v) "native"))
      (when-not (is-simple? v)
        (if (contains? cache v)
          (undef! v)
          (conj! cache v)))) v))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn stringify

  "JSON stringify (no cyclical obj-ref)"
  ^String [obj]

  (if obj (JSON/stringify obj (no-cref))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn opt??

  "If cur is not defined, returns other else cur"
  ^Any [cur other]

  (if (def? cur) cur other))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn cons!

  "Adds one element to the beginning of a collection."
  [x coll]

  (if (Array.isArray coll) (.unshift coll x)) coll)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn conj!

  "conj[oin]. Returns coll with the xs
  'added'. (conj! nil item) returns [item].
  If coll is a list, prepends else appends to coll."
  ^Any [coll & xs]

  (let [c (or coll (vec))]
    (floop [x xs]
      (cond
        (array? c)
        (if (list? c)
          (.unshift c x)
          (.push c x))
        (set? c)
        (.add c x)
        (map? c)
        (.set c (_1 x) (_2 x))
        :else
        (raise! "Cannot conj to: " (type c)))) c))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn conj

  "Like conj! but returns a new collection"
  ^Any [coll & xs]

  (with-local-vars
    [c (cond
         (nichts? coll)
         (vec)
         (list? coll)
         (into (list) coll)
         (vector? coll)
         (into (vector) coll)
         (array? coll)
         (slice coll)
         (map? coll)
         (new Map (.entries coll))
         (set? coll)
         (new Set (.values coll)))])
  (if c (apply conj! this (concat [c] xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn disj!

  "disj[oin]. Returns a set without these keys"
  [coll & xs]

  (if (set? coll)
    (each #(.delete coll %) xs)) coll)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn disj

  "disj[oin]. Returns a new set without these keys"
  [coll & xs]

  (with-local-vars [s2 (new Set xs)])
  (->> (if-not (set? coll)
         (vec)
         (filter #(not (.has s2 %)) (vals coll))) (new Set)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pop!

  "Removes the first element if list,
  else removes the last element,
  returning the element
  and the altered collection"
  ^Array [coll]

  (when (array? coll)
    (with-local-vars
      [r (if (list? coll)
           (.shift coll) (.pop coll))]) (vec r coll)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pop

  "Like pop! but returns a new collection"
  ^Array [coll]

  (when (array? coll)
    (with-local-vars
      [r (if (list? coll)
           (first coll) (last coll))])
    (vec r (if (list? coll)
             (.slice coll 1)
             (.slice coll 0 -1)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn wrap-str

  "Prepend and append strings to the object."
  [obj start end]

  (str start obj end))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getIndex

  "Get the item by indexing."
  [obj pos]

  (if (array? obj)
    (raw# "obj[pos]") undefined))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn getProp

  "If prop is a string, returns the value of
  this object property, obeying the own? flag,
  unless if object is a Map, returns value of
  the key. Otherwise, return the value at the
  index of the array."
  ^Any
  [obj prop & [own?]]

  (cond
    (map? obj) (.get obj prop)
    (nichts? obj) nil
    :t
    (do (set! own? (opt?? own? true))
        (if (or (string? prop)
                (number? prop))
          (if (and own?
                   (string? prop)
                   (not (.hasOwnProperty obj prop)))
            undefined
            (raw# "obj[prop]"))
          undefined))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn prn

  "Print data as string - use to dump an AST node"
  ^String [obj & [r?]]

  (with-local-vars [f (no-cref)])
  (when (complex? obj)
    (set! obj (f nil obj)))
  (if-not obj
    ""
    (prn* obj (opt?? r? true) f)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prnArr*

  "Print an array"
  [obj r? f]

  (join " "
        (map (fn [v i]
               (with-local-vars [x (f i v)])
               (-> (opt?? x nil) (prn* r? f))) obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- prn*

  "Internal print"
  [obj r? func]

  (with-local-vars
    [pfx #(prn* % r? func)
     parr (if (array? obj)
            #(wrap-str
               (prnArr* obj r? func) %1 %2))])

  (cond
    (atom? obj)
    (wrap-str (pfx obj.value) "(atom " ")")
    (inst? core/SValue obj)
    (.-value obj)
    (map? obj)
    (let [acc (vec)]
      (.forEach obj (fn [v,k]
                      (set! v (func k v))
                      (if-not (undef? v)
                        (.push acc (str (pfx k) " " (pfx v))))))
      (.join acc ",")
      (wrap-str acc "{" "}"))
    (set? obj)
    (let [acc (vec)]
      (.forEach obj (fn [v,k]
                      (set! v (func k v))
                      (if-not (undef? v)
                        (.push acc (pfx v)))))
      (.join acc " ")
      (wrap-str acc "#{" "}"))
    (list? obj)
    (parr "(list " ")")
    (array? obj)
    (parr "(vec ", ")")
    (string? obj)
    (if r? (quote-str obj) obj)
    (nil? obj)
    "nil"
    (undef? obj)
    "undefined"
    (object? obj)
    (let [acc (vec)
          keys (Object.keys obj)]
      (.forEach keys (fn [k,v]
                      (set! v (func k (getProp obj k)))
                      (if-not (undef? v)
                        (.push acc (str (pfx k) " " (pfx v))))))
      (.join acc ",")
      (wrap-str acc "(js-obj " ")"))
    :t (str obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn symbol?

  "Check if a symbol"
  [obj]

  (inst? core/SSymbol obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn symbol

  "Create a new Symbol"
  ^SSymbol [name]

  (new core/SSymbol name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn keyword?

  "Check if a keyword"
  [obj]

  (inst? Keyword obj))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn keyword

  "Create a new Keyword"
  ^Keyword [name]

  (new Keyword name))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn keyword->symbol

  "Convert a Keyword to Symbol"
  ^SSymbol [k]

  (with-local-vars
    [s (new core/SSymbol (str k))])
  (oset! s
         :source k.source
         :line  k.line
         :column k.column) s)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn atom?

  "Check if an Atom"
  [atm]

  (inst? Atom atm))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn atom

  "Create a new Atom"
  ^Atom [val]

  (new Atom val))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn reset!

  "Set a new value to the Atom"
  [a v]

  (do->nil (oset! a :value v)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn objClass

  ""
  [obj]

  (if obj (.-constructor obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sort!

  "Returns a sorted sequence of the items in coll.
  If no comparator is supplied, uses compare"
  [comp coll]

  (if (fn? comp) (.sort coll comp) (.sort comp)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn deref

  "Get value inside the Atom"
  ^Any [a]

  (.-value a))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn swap!

  "Change value inside the Atom, returning the new value"
  ^Any [a f & xs]

  (->> (concat (vec a.value) xs)
       (apply f this)
       (oset! a :value )) (get a :value))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn complex?

  "Check x is an array or js object."
  [x]

  (or (array? x)
      (object? x)
      (map? x) (set? x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn simple?

  "Check if x is a primitive value type"
  [obj]

  (or (undef? obj)
      (nil? obj)
      (false? obj) (true? obj) (string? obj) (number? obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn sequential?

  "Check if coll implements Sequential"
  [arr]

  (or (list? arr)(vector? arr)(array? arr)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- eqSets?

  [s1 s2]

  (with-local-vars [ok? #t])
  (when (= (.-size s1)
           (.-size s2))
    (.forEach s1
              (fn [v k]
                (if-not (.has s2 v) (false! ok?))))) ok?)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- eqMaps?

  [m1 m2]

  (with-local-vars [ok? #t])
  (when (== (.-size m1)
            (.-size m2))
    (.forEach m1
              (fn [v k]
                (if-not (eq? (.get m2 k) v) (false! ok?))))) ok?)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- eqArrs?

  [a1 a2]

  (with-local-vars [ok? #t])
  (when (== (.-length a1)
            (.-length a2))
    (.forEach a1
              (fn [v k]
                (if-not (eq? (nth a2 k) v) (false! ok?))))) ok?)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- eqObjs?

  [o1 o2]

  (with-local-vars
    [ok? #t
     k1 (.keys Object o1)
     k2 (.keys Object o2)])
  (when (eqSets? (new Set k1)
                 (new Set k2))
    (.forEach k1
              (fn [k]
                (if-not (eq? (getProp o1 k)
                             (getProp o2 k)) (false! ok?))))) ok?)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn eq?

  "Check if both are equal"
  [a b]

  (cond
    (and (map? a)
         (map? b))
    (eqMaps? a b)

    (and (set? a)
         (set? b))
    (eqSets? a b)

    (and (array? a)
         (array? b))
    (eqArrs? a b)

    (and (regex? a)
         (regex? b))
    (= a.value b.value)

    (and (symbol? a)
         (symbol? b))
    (= a.value b.value)

    (and (keyword? a)
         (keyword? b))
    (= a.value b.value)

    (and (object? a)
         (object? b))
    (eqObjs? a b)
    :t
    (= a b)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn object?

  "Check if a js object"
  [obj]

  (if-not (or (nil? obj)
              (map? obj)
              (set? obj)
              (regex? obj)
              (array? obj)) (rtti? obj "[object Object]")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn last

  "The last element"
  ^Any [coll]

  (if (or (array? coll)
          (string? coll))
    (if (nzlen? coll) (nth coll (last-index coll)))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- into-map

  "Copy stuff into a map."
  [to coll]

  (with-local-vars [len (count coll)])
  (if-not (even? len)
    (raise! "into-map expects even args"))
  (cond
    (map? coll)
    (.forEach coll (fn [v, k] (.set to k v)))
    (set? coll)
    (floop [v (.values coll) :step 2 :index i]
           (.set to (.@i ____coll) (.@+i ____coll)))
    (array? coll)
    (floop [v coll :step 2 :index i]
           (.set to (.@i ____coll) (.@+i ____coll)))
    :t
    (raise! "Bad source data for into-map"))
  to)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- into-set

  "Copy stuff into a set."
  [to coll]

  (cond
    (set? coll)
    (floop [v (.values coll)]
           (.add to v))
    (array? coll)
    (floop [v coll]
           (.add to v))
    :t
    (raise! "Bad source data for into-set"))
  to)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- into-arr

  "Copy stuff into a list or vec."
  [to coll]

  (cond
    (map? coll)
    (.forEach coll (fn [v,k] (.push to (vector k v))))
    (set? coll)
    (floop [v (.values coll)]
           (.push to v))
    (array? coll)
    (floop [v coll]
           (.push to v))
    :t
    (raise! "Bad source data for into-set"))
  to)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn into

  "Returns a new coll consisting of to-coll with all of the items of
from-coll conjoined."

  [to coll]

  (cond
    (array? to)
    (into-arr to coll)
    (map? to)
    (into-map to coll)
    (set? to)
    (into-set to coll)
    :else
    (raise! "Unsupported type for into()"))
  to)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn map?

  "Check if a Map"
  [obj]

  (inst? Map obj))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn set?

  "Check if a Set"
  [obj]

  (inst? Set obj))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn list?

  "Check if a List"
  [obj]

  (inst? SPair obj))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn list
  "Create a List"

  ^SPair [&xs]

  (let [o (new SPair)]
    (.forEach xs (fn [z] (.push o z))) o))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn vector

  "Create a Vector"
  ^DArray [&xs]

  (let [o (new DArray)]
    (.forEach xs (fn [z] (.push o z))) o))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn vec

  "Create a Vector"
  ^DArray [&xs]

  (let [o (new DArray)]
    (.forEach xs (fn [z] (.push o z))) o))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn vector?

  "Check if a Vector"
  [v]

  (inst? DArray v))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn object

  "Create a new js object"
  ^Object [&xs]

  (if (odd? (alen xs))
    (raise! "Invalid arity for object")
    (let [ret (new Object)]
      (floop [:end (count xs) :step 2 :index i]
             (oset! ret (.@i xs) (.@+i xs))) ret)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn seq

  "Returns a sequence"
  ^Array [obj]

  (let [out (list)
        a (cond (string? obj) (obj.split "")
                (array? obj) (obj.slice 0)
                (set? obj) (Array.from (.values obj)))]
    (if a
      (.forEach a (fn [v] (.push out v)))
      (cond
        (map? obj)
        (.forEach obj (fn [v k] (.push out (list k v))))
        (object? obj)
        (.forEach (.keys Object obj) (fn [k] (.push out (list k (oget obj k)))))))
    out))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn rseq

  "Returns a seq of the items in coll in reverse order. If rev is empty returns nil."
  [coll]

  (.reverse (seq coll)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn contains?

  "Check if item is inside"
  [coll x]

  (cond
    (or (array? coll)
        (string? coll)) (.includes coll x)
    (set? coll) (.has coll x)
    (map? coll) (.has coll x)
    (object? coll) (coll.hasOwnProperty x)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn nichts?

  "Check if object is either null of undefined"
  [obj]

  (or (undef? obj) (nil? obj)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn some?

  "Check if object is defined and not null"
  [obj]

  (not (nichts? obj)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn count

  "Count the number of elements inside"
  ^Integer [coll]

  (if coll
    (if (or (map? coll)
            (set? coll))
      (.-size coll)
      (alen (if (or (string? coll)
                    (array? coll)) coll (Object.keys coll)))) 0))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn hash-map

  "Create a map from these key values"
  ^Map [&xs]

  (with-local-vars [ret (new Map)])
  (floop [:index i :end (count xs) :step 2]
         (.set ret (.@i xs) (.@+i xs))) ret)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn hash-set

  "Create a set from these values"
  ^Set [&xs]

  (with-local-vars [ret (new Set)])
  (floop [:index i :end (count xs)]
         (.add ret (.@i xs))) ret)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn concat

  "Add many to this collection"
  [coll & xs]

  (let [out '()]
    (.forEach (seq coll) (fn [x] (.push out x)))
    (.forEach xs (fn [c]
                   (.forEach (seq c) (fn [x] (.push out x)))))
    out))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- repeat-every

  ""
  ^Array [coll start step]

  (with-local-vars [ret (list)])
  (floop [e coll :start start :step step] (.push ret e)) ret)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn evens

  "Collect every 2nd item starting at 0"
  ^Array [coll]

  (repeat-every coll 0 2))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn odds

  "Collect every 2nd item starting at 1"
  ^Array [coll]

  (repeat-every coll 1 2))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn mod

  "Modulo"
  ^Integer [x N]

  (if (< x 0)
    (- x (* -1
            (+ N (* (Math/floor (div (- x) N)) N)))) (rem x N)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn partition

  "Returns a sequence of lists of n items each."
  ^Array [n coll]

  (loop [ret (list)
         [x y] (split-seq coll n)]
    (if (not-empty x) (.push ret x))
    (if (empty? y)
      ret
      (recur ret (split-seq y n)))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn split

  "Splits string on a sep or regular expression.  Optional argument limit is
the maximum number of splits. Returns vector of the splits."
  [s re & [limit]]

  (if (def? limit)
    (.split s re limit) (.split s re)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn split-str

 "Returns a sequence of strings of n characters each."
  [n string]

  (with-local-vars [ret (list)])
  (floop [:end (kirbyref/count string) :step n :index i]
    (.push ret (.substr string i n))) ret)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn interleave

  "Returns a seq of the first item in each coll, then the second, etc"
  ^Array [c1 c2]

  (with-local-vars
    [cz (if (< (alen c2)
               (alen c1)) (alen c2) (alen c1))
     ret (list)])
  (floop [:end cz :index i] (.push ret (.@i c1) (.@i c2))) ret)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn zipmap

  "Returns an object with the keys mapped to the corresponding vals"
  ^Map [keys vals]

  (with-local-vars
    [ret (new Map)
     cz (if (< (alen keys)
               (alen vals)) (alen keys) (alen vals))])
  (floop [:end cz :index i]
         (assoc! ret (.@i keys) (.@i vals))) ret)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn zipobj

  "Returns an object with the keys mapped to the corresponding vals"
  ^Map [keys vals]

  (with-local-vars
   [ret (new Object)
    cz (if (< (alen keys)
              (alen vals)) (alen keys) (alen vals))])
  (floop [:end cz :index i]
         (assoc! ret (str (.@i keys)) (.@i vals))) ret)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn extendAttr

  ""
  ^Object [obj attr & [flags]]

  (set! flags (opt?? flags
                     (js-obj :enumerable #f :writable #t)))
  (Object.defineProperty obj attr flags) obj)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn cons

  "Returns a new seq where x is the first element and seq is the rest."
  [x coll]

  (when (array? coll) (.concat (list x) coll)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- gensym-counter 0)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn gensym

  "Generates next random symbol"
  ^SSymbol [& [pfx]]

  (let [v gensym-counter]
    (inc gensym-counter)
    (symbol (str (opt?? pfx "GS__") v))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn assoc!

  ""
  ^Any [obj & xs]

  (when obj
    (floop [k xs :step 2 :index i]
      (with-local-vars [v (nexth xs i)])
      (cond
        (map? obj) (.set obj k v)
        (object? obj) (raw# "obj[k]=v")))) obj)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn dissoc!

  ""
  ^Any [obj & xs]

  (when obj
    (doseq [k xs]
      (cond
        (map? obj) (.delete obj k)
        (object? obj) (raw# "delete obj[k]")))) obj)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn truthy?

  "LISP truthy"
  [a]

  (not (falsy? a)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn falsy?

  "LISP falsy"
  [a]

  (or (nil? a)(false? a)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn flatten

  "Flatten an array"
  [xs]

  (reduce (fn [acc v] (concat acc v)) (list) xs))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn identity

  "Returns its argument."
  [x]

  x)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;monads
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmonad monad-identity

  "Monad describing plain computations. This monad does in fact nothing
  at all. It is useful for testing, for combination with monad
  transformers, and for code that is parameterized with a monad."

  [ bind (fn [mv mf] (mf mv)) unit #(identity %1)] )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmonad monad-maybe

  "Monad describing computations with possible failures. Failure is
  represented by nil, any other value is considered valid. As soon as
  a step returns nil, the whole computation will yield nil as well."

  [bind (fn [mv mf]
          (if-not (nil? mv) (mf mv))) unit #(identity %1) zero nil] )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmonad monad-list

  "Monad describing multi-valued computations, i.e. computations
  that can yield multiple values. Any object implementing the seq
  protocol can be used as a monadic value."

  [bind (fn [mv mf] (flatten (map mf mv)))
   unit #(concat [] %)
   zero []
   plus #(flatten ____args) ])
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmonad monad-state

  "Monad describing stateful computations. The monadic values have the
  structure (fn [old-state] [result new-state])."

  [bind (fn [mv mf]
          (fn [state]
            (let [[value newState] (mv state)]
              ((mf value) newState))))
   unit (fn [v] #(vec v %1)) ])
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defmonad monad-continuation

  "Monad describing computations in continuation-passing style. The monadic
  values are functions that are called with a single argument representing
  the continuation of the computation, to which they pass their result."

  [bind (fn [mv mf]
          (fn [cont]
            (mv (fn [value] ((mf value) cont)))))
   unit (fn [value] (fn [cont] (cont value))) ])
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn run-monad-continuation

  "Execute the computation cont
  in the cont monad and return its result."
  [cont]

  (cont identity))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn quote-str

  "Add quotes around a string"
  ^String [s]

  (with-local-vars [ch "" out "\""])
  (floop [:index i :end (count s)]
    (set! ch (ch@ s i))
    (cond
      (= ch "\"") (+= out "\\\"")
      (= ch "\n") (+= out "\\n")
      (= ch "\t") (+= out "\\t")
      (= ch "\f") (+= out "\\f")
      (= ch "\r") (+= out "\\r")
      (= ch "\v") (+= out "\\v")
      (= ch "\\") (+= out (if (= "u" (ch@ s (inc i))) ch "\\\\"))
      :t (+= out ch)))
  (+= out "\""))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn unquote-str

  "Removes quotes around a string"
  ^String [s]

  (if (and (string? s)
           (starts-with? s "\"")
           (ends-with? s "\""))
    (do-with [out ""]
      (set! s (s.slice 1 -1))
      (floop [:index i :end (count s)]
        (with-local-vars [nx undefined
                          ch (ch@ s i)])
        (if (= ch "\\")
          (do (++ i)
              (set! nx (ch@ s i))
              (cond
                (= nx "\"") (+= out "\"")
                (= nx "\\") (+= out "\\")
                (= nx "n") (+= out "\n")
                (= nx "t") (+= out "\t")
                (= nx "f") (+= out "\f")
                (= nx "v") (+= out "\v")
                (= nx "r") (+= out "\r")
                :else (do (+= out ch) (-- i))))
          (+= out ch))))
    s))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn esc-xml

  "Escape XML special chars"
  ^String [s]

  (with-local-vars [out ""])
  (doseq [c s]
    (cond
      (= c "&") (set! c "&amp;")
      (= c ">") (set! c "&gt;")
      (= c "<") (set! c "&lt;")
      (= c "\"") (set! c "&quot;")
      (= c "'") (set! c "&apos;"))
    (+= out c))
  out)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn split-seq

  "Split a collection into 2 parts"
  ^Array [coll cnt]

  (if (< cnt (count coll))
    [(take cnt coll) (drop cnt coll)] [(slice coll 0) []]))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn select-keys

  "Get a subset of keys"
  ^Map [coll keys]

  (reduce
    (fn [acc n]
      (assoc! acc
              n
              (.get coll n))) (new Map) (seq keys)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- do-update-in!

  ""
  [coll n func args err]

  (with-local-vars
   [cur (cond
          (number? n)
          (if (and (array? coll)
                   (< n (alen coll))) (nth coll n) (err n))
          :t (.get coll n))
    v (apply func this (cons cur args))])
  (assoc! coll n v))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn update-in!

  "'Updates' a value in a nested associative structure, where ks is a
sequence of keys and f is a function that will take the old value
and any supplied args and return the new value, and returns a new
nested structure.  If any levels do not exist, hash-maps will be
created."
  ^Map [coll keys func & xs]

  (with-local-vars
   [err #(raise! "update-in! failed, bad nested keys: " %)
    root coll
    m nil
    end (last-index keys)])
  (floop [n keys :index i :while (<= i end)]
    (cond
      (== i end)
      (do-update-in! root n func xs err)
      (number? n)
      (if-not (and (array? root)
                   (< n (alen root)))
        (err n)
        (set! root (nth root n)))
      :t
      (do (set! m (.get root n))
          (when (undef? m) (set! m (new Map)) (assoc! root n m))
          (if-not (map? m) (err n))
          (set! root m))))
  coll)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn get-in

  "Returns the value in a nested associative structure,
  where ks is a sequence of keys. Returns nil if the key
  is not present, or the not-found value if supplied."
  ^Any [coll keys]

  (with-local-vars
   [root coll
    ret nil
    m nil
    n nil
    end (last-index keys)])
  (floop [n keys :index i :while (<= i end)]
    (cond
      (number? n)
      (if-not (and (array? root)
                   (< n (alen root)))
        (do->break! (set! ret nil))
        (set! root (nth root n)
              ret root))
      :t
      (do (set! root (.get root n)
                ret root)))) ret)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- merge!

  ""
  [base m]

  (with-local-vars [ret (or base (new Map))
                    src (or m (new Map))])
  (each-key (fn [v k] (assoc! ret k v)) src) ret)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn- mix!

  ""
  [base m]

  (with-local-vars [ret (or base (js-obj))
                    src (or m (js-obj))])
  (each-key (fn [v k] (oset! ret k v)) src) ret)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn merge

  "Returns a map that consists of the rest of the maps conj-ed onto
the first.  If a key occurs in more than one map, the mapping from
the latter (left-to-right) will be the mapping in the result."
  [&maps]

  (reduce (fn [acc n] (merge! acc n)) (new Map) maps))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn mixin

  "Returns an object that consists of the rest of the objects conj-ed onto
the first.  If a property occurs in more than one object, the mapping from
the latter (left-to-right) will be the mapping in the result."
  [&objs]

  (reduce (fn [acc n] (mix! acc n)) (js-obj) objs))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn fill-array

  ""
  [len v]

  (with-local-vars [ret (vec)])
  (dotimes [x len]
    (.push ret (if (fn? v) (v x) v))) ret)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn copy-array

  ""
  [src des]

  (with-local-vars [sz (Math/min (kirbyref/count src)
                                 (kirbyref/count des))])
  (floop [:end sz :index i]
         (aset des i (nth src i))) des)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn aclone

  "Creates a clone of the given JavaScript array.
  The result is a new array, which is a shallow copy."
  [src]

  (if (array? src) (.slice src 0)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn difference

  "Return a set that is the first set
  without elements of the other set."
  [a b]

  (with-local-vars [ret (vec)])
  (doseq [z a]
    (if-not (contains? b z) (.push ret z)))
  (new Set ret))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn percent

  ""
  ^Number [numerator denominator]

  (* 100.0 (div numerator denominator)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn to-fixed

  ""
  ^String [num digits]

  (set! digits (opt?? digits 2))
  (.toFixed (Number num) digits))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn mapcat

  ""
  [func coll]

  (with-local-vars [ret (list)])
  (ret.concat.apply ret (map func coll)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;testing stuff
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn ensure-test

  ""
  [cnd msg]

  (set! msg (or msg "test"))
  (try (str (if cnd "passed:" "FAILED:") " " msg)
       (catch e (str "FAILED: " msg))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn ensure-test-thrown

  ""
  [expected error msg]

  (if (nil? error)
    (str "FAILED: " msg)
    (if (or (== expected (type error))
            (== expected "any"))
      (str "passed: " msg)
      (str "FAILED: " msg))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn run-test

  ""
  [test & [title]]

  (set! title (opt?? title "test"))
  (with-local-vars
    [now (new Date)
     results (test)
     sum (kirbyref/count results)
     ok (kirbyref/count (filter #(starts-with? % "p") results))
     ps (to-fixed (percent ok sum))])
  (->> [(.repeat "+" 78)
        title now
        (.repeat "+" 78)
        (join "\n" results)
        (.repeat "=" 78)
        (str "Passed: " ok "/" sum " [" ps "%]")
        (str "Failed: " (- sum ok))
        (str "CPU Time: " (- (new Date) now) "ms")]
       (join "\n")))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(def- *ns-cache* (vec {:id "user" :meta nil}))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn push-nsp

  ""
  [nsp & [info]]

  (.unshift *ns-cache* {:id nsp :meta info}))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn pop-nsp

  ""
  []

  (.shift *ns-cache*))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn peek-nsp

  ""
  []

  (nth *ns-cache* 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn *ns*

  ""
  []

  (if-some [n (peek-nsp)] (get n :id)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn min-by

  ""
  [func coll]

  (when (not-empty coll)
    (reduce (fn [a b] (if (< (func a) (func b)) a b)) (_1 coll) (rest coll))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn max-by

  ""
  [func coll]

  (when (not-empty coll)
    (reduce (fn [a b] (if (< (func a) (func b)) b a)) (_1 coll) (rest coll))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn take-while

  "Returns a sequence of successive items from coll while
(pred item) returns logical true. pred must be free of side-effects."
  [pred coll]

  (with-local-vars [ret (list)])
  (floop [c coll]
    (if (pred c)
      (.push ret c)
      (break-out-of-loop!))) ret)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn drop-while

  "Returns a sequence of the items in coll starting from the
first item for which (pred item) returns logical false."
  [pred coll]

  (with-local-vars [ret (list)])
  (floop [c coll :index i]
    (when-not (pred c)
      (floop [xx coll :start i :index k] (.push ret xx))
      (break-out-of-loop!))) ret)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defn split-with

  "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"
  [pred coll]

  (vec (take-while pred coll) (drop-while pred coll)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;EOF



